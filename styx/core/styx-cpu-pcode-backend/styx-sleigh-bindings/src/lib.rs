// BSD 2-Clause License
//
// Copyright (c) 2024, Styx Emulator Project
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//! Rust bindings for the Ghidra's Sleigh `libsla`.
//!
//! The bindings are created using [cxx](https://docs.rs/cxx/latest/cxx/) and
//! are found in the [ffi] module.
//!
//! ## Sleigh Source Code
//!
//! Sleigh C++ code is taken from Ghidra 11.0.3. The `zlib` folder holds zlib
//! sources from the same Ghidra release.
//!
//! Updating the sleigh sources is as simple as copying over the sources from
//! `Ghidra/Features/Decompiler/src/decompile/cpp/` over to `sleigh/`.
//!
//! The only change made is the `main()` function in slgh_compile.cc name was
//! changed to allow inclusion of the SleighCompile facilities.
use cxx::CxxVector;

/// Implement to act as a p-code emit for sleigh
pub trait PCodeEmit {
    /// Callback that will be called when disassembling, emitting the pcode
    /// - `address` - the address of the machine instruction
    /// - `opcode` - the opcode of the particular pcode instruction
    /// - `outvar` - a data about the output varnode
    /// - `vars` - an array of VarnodeData for each input varnode
    fn dump(
        &mut self,
        address: &ffi::Address,
        opcode: u32,
        outvar: Option<&ffi::VarnodeData>,
        vars: &CxxVector<ffi::VarnodeData>,
    );
}

/// "Abstract class" for sleigh's LoadImage.
///
/// Wrapped by [[RustLoadImage]].
pub trait LoadImage {
    fn load_fill(&mut self, ptr: &mut [u8], addr: &ffi::Address);
    fn adjust_vma(&mut self, _adjust: isize) {}
}

/// Implementation of sleigh's LoadImage, in rust.
pub struct RustLoadImage<'a> {
    internal: &'a mut dyn LoadImage,
}

impl<'a> RustLoadImage<'a> {
    pub fn from_internal(internal: &'a mut dyn LoadImage) -> Self {
        Self { internal }
    }

    unsafe fn load_fill(&mut self, ptr: *mut u8, size: u32, addr: &ffi::Address) {
        let slice = std::slice::from_raw_parts_mut(ptr, size as usize);
        self.internal.load_fill(slice, addr);
    }

    fn adjust_vma(&mut self, adjust: isize) {
        self.internal.adjust_vma(adjust)
    }
}

/// "Abstract class" for sleigh's PCodeEmit.
///
/// Wrapped by [[RustPCodeEmit]].
pub struct RustPCodeEmit<'a> {
    pub internal: &'a mut dyn PCodeEmit,
}

/// Implementation of sleigh's PCodeEmit, in rust.
impl<'a> RustPCodeEmit<'a> {
    pub fn from_internal(internal: &'a mut dyn PCodeEmit) -> Self {
        Self { internal }
    }

    unsafe fn dump(
        &mut self,
        address: &ffi::Address,
        opcode: u32,
        outvar: *const ffi::VarnodeData,
        vars: &CxxVector<ffi::VarnodeData>,
    ) {
        let outvar = if outvar.is_null() {
            None
        } else {
            Some(&*outvar)
        };
        self.internal.dump(address, opcode, outvar, vars);
    }
}

/// Primary module for C++ bindings, generated by `cxx`.
///
/// In most cases, objects should be put in a [UniquePtr](cxx::UniquePtr) to
/// easily handle object creation/cleanup.
#[allow(clippy::missing_safety_doc)] // cxx doesn't pass through safety docs
#[cxx::bridge(namespace = "ghidra")]
pub mod ffi {
    extern "Rust" {
        type RustPCodeEmit<'a>;
        unsafe fn dump(
            self: &mut RustPCodeEmit,
            address: &Address,
            opcode: u32,
            outvar: *const VarnodeData,
            vars: &CxxVector<VarnodeData>,
        );

        type RustLoadImage<'a>;
        unsafe fn load_fill(self: &mut RustLoadImage, ptr: *mut u8, size: u32, addr: &Address);
        fn adjust_vma(self: &mut RustLoadImage, adjust: isize);
    }

    unsafe extern "C++" {
        include!("bridge.hh");
        // Types needed in ffi2 (extern Rust OR extern C++)
        type Address;
        unsafe fn new_address(addr_spc: *mut AddrSpace, offset: u64) -> UniquePtr<Address>;
        fn getOffset(self: &Address) -> u64;

        type AddrSpace;
        fn getName(self: &AddrSpace) -> &CxxString;
        fn getWordSize(self: &AddrSpace) -> u32;
        fn getAddrSize(self: &AddrSpace) -> u32;
        fn isBigEndian(self: &AddrSpace) -> bool;

        type AddrSpaceManager;
        fn getSpaceByName(self: &AddrSpaceManager, name: &CxxString) -> *mut AddrSpace;
        fn numSpaces(self: &AddrSpaceManager) -> i32;
        fn getSpace(self: &AddrSpaceManager, idx: i32) -> *mut AddrSpace;
        fn getUniqueSpace(self: &AddrSpaceManager) -> *mut AddrSpace;
        fn getDefaultCodeSpace(self: &AddrSpaceManager) -> *mut AddrSpace;

        type VarnodeData;
        fn getVarnodeSize(data: &VarnodeData) -> u32;
        fn getVarnodeSpace(data: &VarnodeData) -> *mut AddrSpace;
        fn getVarnodeOffset(data: &VarnodeData) -> u64;

        type DocumentStorage;
        fn newDocumentStorage(s: &CxxString) -> Result<UniquePtr<DocumentStorage>>;

        type Sleigh;
        /// # Safety
        ///
        /// `load_image` and `context_db` must be valid and exist while Sleigh is used.
        unsafe fn new_sleigh(
            load_image: *mut LoadImage,
            context_db: *mut ContextDatabase,
        ) -> UniquePtr<Sleigh>;
        fn getRegisterProxy<'a>(sleigh: &'a Sleigh, reg: &CxxString) -> Result<&'a VarnodeData>;
        fn initialize(self: Pin<&mut Sleigh>, dom: Pin<&mut DocumentStorage>) -> Result<()>;
        fn setContextVariableCached(
            self: Pin<&mut Sleigh>,
            str: &CxxString,
            addr: &Address,
            value: u32,
        );

        type SleighBase;
        fn getUserOps(sleigh: &Sleigh) -> UniquePtr<CxxVector<UserOpData>>;
        fn getRegisters(sleigh: &Sleigh) -> UniquePtr<CxxVector<RegisterData>>;
        type Translate;
        fn isBigEndian(self: &Translate) -> bool;

        type UserOpData;
        fn getIndex(self: &UserOpData) -> u32;
        fn getName(self: &UserOpData) -> &CxxString;

        type RegisterData;
        fn getVarnodeData(self: &RegisterData) -> &VarnodeData;
        fn getName(self: &RegisterData) -> &CxxString;

        type ContextInternal;
        fn new_context_internal() -> UniquePtr<ContextInternal>;
        type ContextDatabase;
        fn setVariable(
            self: Pin<&mut ContextDatabase>,
            str: &CxxString,
            addr: &Address,
            value: u32,
        );

        type LoadImage;
        type RustLoadImageProxy;

        type SleighCompile;
        fn new_sleigh_compile() -> UniquePtr<SleighCompile>;
        fn run_compilation(
            self: Pin<&mut SleighCompile>,
            infile: &CxxString,
            outfile: &CxxString,
        ) -> i32;

        /// Create a new RustLoadImageProxy.
        ///
        /// # Safety
        ///
        /// `loadImage` must live as long as the created [RustLoadImage].
        unsafe fn newRustLoadImageProxy(
            loadImage: *mut RustLoadImage,
        ) -> UniquePtr<RustLoadImageProxy>;

        /// Create a new RustLoadImageProxy.
        ///
        /// # Safety
        ///
        /// `emit` must point to a valid instance of RustPCodeEmit and must live through the
        /// function call.
        unsafe fn sleighOneInstruction(
            sleigh: &Sleigh,
            emit: *mut RustPCodeEmit,
            addr: u64,
        ) -> Result<i32>;
    }

    impl UniquePtr<ContextDatabase> {}
    impl UniquePtr<LoadImage> {}
    impl UniquePtr<AddrSpaceManager> {}
    impl UniquePtr<Translate> {}
    impl UniquePtr<SleighBase> {}
}

#[cfg(test)]
mod tests {
    use super::*;
    use cxx::let_cxx_string;

    #[test]
    #[cfg_attr(miri, ignore)]
    fn test_create_context_internal() {
        let context = ffi::new_context_internal();

        assert!(!context.is_null())
    }

    // test a valid xml document through the DocumentStorage
    #[test]
    #[cfg_attr(miri, ignore)]
    fn test_dom_valid() {
        let spec = r#"<sleigh>sleigh bells</sleigh>"#;
        let_cxx_string!(spec_cxx = spec);

        let dom = ffi::newDocumentStorage(&spec_cxx);

        assert!(dom.is_ok())
    }

    // test an invalid xml document through the DocumentStorage
    #[test]
    #[cfg_attr(miri, ignore)]
    fn test_dom_invalid() {
        let spec = "This is not a valid xml spec";
        let_cxx_string!(spec_cxx = spec);

        let dom = ffi::newDocumentStorage(&spec_cxx);

        assert!(dom.is_err())
    }
}
