// SPDX-License-Identifier: BSD-2-Clause
//! Manages sla specs and provides compiled slas.
//!
//! Provides the following:
//! - Source of truth for slaspec sources.
//! - Apply patches to specs.
//! - Compiled to sla and provided as const static byte slices
//! - Provides generated types for definitions (currently only user ops)
//!
//! ## Sla Specifications
//!
//! Sla specs are located in the `processors/` directory. The
//! `processors/ghidra/` directory is a copy of `Ghidra/Processors/` directory
//! in Ghidra sources. Processor definitions not sourced from Ghidra can be
//! placed under `processors/custom/`
//!
//! ## Patches
//!
//! Patches should be in unified format in the `patches/` folder. The directory
//! folder matches that of the `processors/` folder. The name of the patch file
//! should match the modified file name with the `.patch` extension added. The
//! names of modified files in the patch files are not read.
//!
//! Patches are created using [diffy](https://docs.rs/diffy/latest/diffy/).
//!
//! ### Patches from Github Pull Requests
//!
//! You can get PRs from GitHub in unified diff format by appending `.patch` or
//! `.diff` to the PR URL.
//!
//! For example:
//!
//! ```text
//! https://github.com/styx-emulator/styx-emulator/pull/353
//! https://github.com/styx-emulator/styx-emulator/pull/353.patch
//! https://github.com/styx-emulator/styx-emulator/pull/353.diff
//! ```
//!
//! ### Common Errors
//!
//! If you receive an `failed to apply patch: error applying hunk #n` for your
//! last hunk when building `styx-sla`, check to see if you have a trailing
//! newline. This is required if the final hunk in your patch is not the final
//! line in your patched file.
//!
use styx_cpu_type::arch::CpuRegister;
use styx_pcode::sla::{SlaSpec, SlaUserOps, UserOps};

use derive_more::{Display, FromStr};

// Generated by build.rs
include!(concat!(env!("OUT_DIR"), "/sla_artifacts.rs"));

/// Defines conversion from [CpuRegister] to string for register lookup.
pub trait SlaRegisters {
    /// Return the symbol string in the sla spec corresponding to the given
    /// register. In the majority case this is a lower case conversion from the
    /// [CpuRegister::name()] but individual registers can be matched with
    /// custom names as well.
    fn translate_register(register: &CpuRegister) -> Box<str> {
        register.name().into()
    }
}

#[cfg(feature = "arch_aarch64")]
impl SlaRegisters for Aarch64 {
    fn translate_register(register: &CpuRegister) -> Box<str> {
        // aarch64 sla has all lowercase register names
        register.name().to_lowercase().into_boxed_str()
    }
}

#[cfg(feature = "arch_arm")]
mod arm {
    use styx_cpu_type::arch::CpuRegister;

    /// common to all that use ARM.sinc where registers are defined
    fn translate_arm(register: &CpuRegister) -> Box<str> {
        // arm sla has all lowercase register names
        register.name().to_lowercase().into_boxed_str()
    }

    /// impl [`crate::SlaRegisters`] using [`translate_arm`]
    macro_rules! arm_sla_registers (
        ($p:ty) => {
            impl crate::SlaRegisters for $p {
                fn translate_register(register: &CpuRegister) -> Box<str> {
                    translate_arm(register)
                }
            }
        };
    );

    arm_sla_registers!(crate::Arm7Le);
    arm_sla_registers!(crate::Arm4Be);
    arm_sla_registers!(crate::Arm5Be);
    arm_sla_registers!(crate::Arm6Be);
    arm_sla_registers!(crate::Arm7Be);
    arm_sla_registers!(crate::Arm8Be);

    #[cfg(test)]
    mod tests {
        use crate::{Arm5BeUserOps, Arm7BeUserOps, Arm7LeUserOps};
        use core::str::FromStr;

        #[test]
        fn test_str() {
            assert_eq!(Arm7BeUserOps::Absolute.to_string(), "Absolute");
            assert_eq!(
                Arm7BeUserOps::from_str("Absolute").unwrap(),
                Arm7BeUserOps::Absolute
            );
            assert_eq!(
                Arm5BeUserOps::from_str(&Arm7LeUserOps::Absolute.to_string()).unwrap(),
                Arm5BeUserOps::Absolute
            );
        }
    }
}

#[cfg(feature = "arch_bfin")]
impl SlaRegisters for Blackfin {
    fn translate_register(register: &CpuRegister) -> Box<str> {
        use styx_cpu_type::arch::{
            backends::{ArchRegister, BasicArchRegister},
            blackfin::BlackfinRegister,
        };

        let name = match register.variant() {
            ArchRegister::Basic(BasicArchRegister::Blackfin(BlackfinRegister::A0w)) => "A0.W",
            ArchRegister::Basic(BasicArchRegister::Blackfin(BlackfinRegister::A0x)) => "A0.X",
            ArchRegister::Basic(BasicArchRegister::Blackfin(BlackfinRegister::A1w)) => "A1.W",
            ArchRegister::Basic(BasicArchRegister::Blackfin(BlackfinRegister::A1x)) => "A1.X",
            _ => register.name(),
        };

        // blackfin sla has almost all uppercase register names, we need a special case for the ASTAT flag registers
        if name.contains("flag") {
            name.to_string().into_boxed_str()
        } else {
            name.to_uppercase().into_boxed_str()
        }
    }
}

#[cfg(feature = "arch_superh")]
impl SlaRegisters for SuperH4Be {
    fn translate_register(register: &CpuRegister) -> Box<str> {
        let lower_name = register.name().to_lowercase();

        // some ghidra developer thought they'd be funny
        match lower_name.as_str() {
            "r0b" => "R0_BANK".into(),
            "r1b" => "R1_BANK".into(),
            "r2b" => "R2_BANK".into(),
            "r3b" => "R3_BANK".into(),
            "r4b" => "R4_BANK".into(),
            "r5b" => "R5_BANK".into(),
            "r6b" => "R6_BANK".into(),
            "r7b" => "R7_BANK".into(),
            "gbr" | "sr" | "ssr" | "spc" | "vbr" | "sgr" | "dbr" | "mach" | "macl" | "pr"
            | "pc" | "fpscr" | "fpul" => lower_name.to_uppercase().into_boxed_str(),
            _ => lower_name.into_boxed_str(),
        }
    }
}

#[cfg(feature = "arch_superh")]
impl SlaRegisters for SuperH4Le {
    fn translate_register(register: &CpuRegister) -> Box<str> {
        let lower_name = register.name().to_lowercase();

        // some ghidra developer thought they'd be funny
        match lower_name.as_str() {
            "gbr" | "sr" | "ssr" | "spc" | "vbr" | "sgr" | "dbr" | "mach" | "macl" | "pr"
            | "pc" | "fpscr" | "fpul" => lower_name.to_uppercase().into_boxed_str(),
            _ => lower_name.into_boxed_str(),
        }
    }
}

#[cfg(feature = "arch_superh")]
impl SlaRegisters for Sh1 {
    fn translate_register(register: &CpuRegister) -> Box<str> {
        // all lowercare registers
        register.name().to_lowercase().into_boxed_str()
    }
}

#[cfg(feature = "arch_superh")]
impl SlaRegisters for Sh2 {
    fn translate_register(register: &CpuRegister) -> Box<str> {
        // all lowercare registers
        register.name().to_lowercase().into_boxed_str()
    }
}

#[cfg(feature = "arch_superh")]
impl SlaRegisters for Sh2a {
    fn translate_register(register: &CpuRegister) -> Box<str> {
        // all lowercare registers
        register.name().to_lowercase().into_boxed_str()
    }
}

#[cfg(feature = "arch_ppc")]
#[allow(unused_imports)] // wrong, this is a re-export
pub use ppc::*;
#[cfg(feature = "arch_ppc")]
mod ppc {
    //! PowerPC sla specifications
    //!
    //! Note: ppc_embedded.sinc may have mistakes.
    //!
    //! We've identified one mistake in the implementation of `mtmsr`
    //! instruction where the processor specification follows the "general
    //! processor" PowerISA instead of the embedded specification. If there are
    //! more differences we will construct an entirely new spec based on the
    //! Ghidra spec, instead of applying patches.

    use styx_cpu_type::arch::{
        backends::{ArchRegister, BasicArchRegister, SpecialArchRegister},
        ppc32::{Ppc32Register, SpecialPpc32Register, SprRegister},
        CpuRegister,
    };

    use crate::{Ppc324xxBe, SlaRegisters};

    impl SlaRegisters for Ppc324xxBe {
        fn translate_register(register: &CpuRegister) -> Box<str> {
            let variant = register.variant();

            match variant {
                ArchRegister::Basic(BasicArchRegister::Ppc32(reg)) => ppc32_basic(register, reg),
                ArchRegister::Special(SpecialArchRegister::Ppc32(
                    SpecialPpc32Register::SprRegister(spr),
                )) => ppc32_special(spr),
                _ => "".to_owned().into_boxed_str(),
            }
        }
    }

    fn ppc32_special(spr: SprRegister) -> Box<str> {
        let spr_idx = spr.index();
        format!("spr{spr_idx:03x}").into_boxed_str()
    }

    fn ppc32_basic(register: &CpuRegister, reg: Ppc32Register) -> Box<str> {
        // note, there exists `crall` which you would think is Ppc32Register::CR,
        // however, ghidra represents `crall` as cr0-cr7 each taking a byte, when ppc
        // is actually cr0-cr7 each taking 4 bits. implemented in register handler instead ðŸ‘
        match reg {
            Ppc32Register::R0
            | Ppc32Register::R1
            | Ppc32Register::R2
            | Ppc32Register::R3
            | Ppc32Register::R4
            | Ppc32Register::R5
            | Ppc32Register::R6
            | Ppc32Register::R7
            | Ppc32Register::R8
            | Ppc32Register::R9
            | Ppc32Register::R10
            | Ppc32Register::R11
            | Ppc32Register::R12
            | Ppc32Register::R13
            | Ppc32Register::R14
            | Ppc32Register::R15
            | Ppc32Register::R16
            | Ppc32Register::R17
            | Ppc32Register::R18
            | Ppc32Register::R19
            | Ppc32Register::R20
            | Ppc32Register::R21
            | Ppc32Register::R22
            | Ppc32Register::R23
            | Ppc32Register::R24
            | Ppc32Register::R25
            | Ppc32Register::R26
            | Ppc32Register::R27
            | Ppc32Register::R28
            | Ppc32Register::R29
            | Ppc32Register::R30
            | Ppc32Register::R31
            | Ppc32Register::Cr0
            | Ppc32Register::Cr1
            | Ppc32Register::Cr2
            | Ppc32Register::Cr3
            | Ppc32Register::Cr4
            | Ppc32Register::Cr5
            | Ppc32Register::Cr6
            | Ppc32Register::Cr7
            | Ppc32Register::Pc => register.name().to_lowercase(),
            Ppc32Register::TblR => "TBLr".to_owned(),
            Ppc32Register::TbuR => "TBUr".to_owned(),
            Ppc32Register::TblW => "TBLw".to_owned(),
            Ppc32Register::TbuW => "TBUw".to_owned(),
            _ => register.name().to_uppercase(),
        }
        .into_boxed_str()
    }
}

#[cfg(feature = "arch_m32r")]
#[allow(unused_imports)] // wrong, this is a re-export
pub use m32r::*;
#[cfg(feature = "arch_m32r")]
mod m32r {
    //! M32R sla specifications

    use styx_cpu_type::arch::CpuRegister;

    use crate::{M32r, SlaRegisters};

    impl SlaRegisters for M32r {
        fn translate_register(_register: &CpuRegister) -> Box<str> {
            unimplemented!()
        }
    }
}

#[cfg(any(feature = "arch_mips32", feature = "arch_mips64"))]
mod mips_common {
    use styx_cpu_type::arch::{
        backends::{ArchRegister, BasicArchRegister},
        mips32::Mips32Register,
        mips64::Mips64Register,
        CpuRegister,
    };

    pub(crate) fn translate_register(register: &CpuRegister) -> Box<str> {
        match register.variant() {
            // mips.sinc uses names from the O32 abi
            ArchRegister::Basic(BasicArchRegister::Mips32(reg)) => match reg {
                Mips32Register::R0 => "zero",
                Mips32Register::R1 => "at",
                Mips32Register::R2 => "v0",
                Mips32Register::R3 => "v1",
                Mips32Register::R4 => "a0",
                Mips32Register::R5 => "a1",
                Mips32Register::R6 => "a2",
                Mips32Register::R7 => "a3",
                Mips32Register::R8 => "t0",
                Mips32Register::R9 => "t1",
                Mips32Register::R10 => "t2",
                Mips32Register::R11 => "t3",
                Mips32Register::R12 => "t4",
                Mips32Register::R13 => "t5",
                Mips32Register::R14 => "t6",
                Mips32Register::R15 => "t7",
                Mips32Register::R16 => "s0",
                Mips32Register::R17 => "s1",
                Mips32Register::R18 => "s2",
                Mips32Register::R19 => "s3",
                Mips32Register::R20 => "s4",
                Mips32Register::R21 => "s5",
                Mips32Register::R22 => "s6",
                Mips32Register::R23 => "s7",
                Mips32Register::R24 => "t8",
                Mips32Register::R25 => "t9",
                Mips32Register::R26 => "k0",
                Mips32Register::R27 => "k1",
                Mips32Register::R28 => "gp",
                Mips32Register::R29 => "sp",
                Mips32Register::R30 => "s8",
                Mips32Register::R31 => "ra",
                _ => reg.register().name(),
            },
            ArchRegister::Basic(BasicArchRegister::Mips64(reg)) => match reg {
                Mips64Register::R0 => "zero",
                Mips64Register::R1 => "at",
                Mips64Register::R2 => "v0",
                Mips64Register::R3 => "v1",
                Mips64Register::R4 => "a0",
                Mips64Register::R5 => "a1",
                Mips64Register::R6 => "a2",
                Mips64Register::R7 => "a3",
                Mips64Register::R8 => "t0",
                Mips64Register::R9 => "t1",
                Mips64Register::R10 => "t2",
                Mips64Register::R11 => "t3",
                Mips64Register::R12 => "t4",
                Mips64Register::R13 => "t5",
                Mips64Register::R14 => "t6",
                Mips64Register::R15 => "t7",
                Mips64Register::R16 => "s0",
                Mips64Register::R17 => "s1",
                Mips64Register::R18 => "s2",
                Mips64Register::R19 => "s3",
                Mips64Register::R20 => "s4",
                Mips64Register::R21 => "s5",
                Mips64Register::R22 => "s6",
                Mips64Register::R23 => "s7",
                Mips64Register::R24 => "t8",
                Mips64Register::R25 => "t9",
                Mips64Register::R26 => "k0",
                Mips64Register::R27 => "k1",
                Mips64Register::R28 => "gp",
                Mips64Register::R29 => "sp",
                Mips64Register::R30 => "s8",
                Mips64Register::R31 => "ra",
                _ => reg.register().name(),
            },
            _ => "",
        }
        .to_lowercase()
        .into()
    }
}

#[cfg(feature = "arch_mips32")]
mod mips32 {
    //! mips32 sla specifications

    use super::*;

    impl SlaRegisters for Mips32be {
        fn translate_register(register: &CpuRegister) -> Box<str> {
            crate::mips_common::translate_register(register)
        }
    }

    impl SlaRegisters for Mips32le {
        fn translate_register(register: &CpuRegister) -> Box<str> {
            crate::mips_common::translate_register(register)
        }
    }
}

#[cfg(feature = "arch_mips64")]
mod mips64 {
    //! mips64 sla specifications

    use super::*;

    impl SlaRegisters for Mips64be {
        fn translate_register(register: &CpuRegister) -> Box<str> {
            crate::mips_common::translate_register(register)
        }
    }

    impl SlaRegisters for Mips64le {
        fn translate_register(register: &CpuRegister) -> Box<str> {
            crate::mips_common::translate_register(register)
        }
    }
}

#[cfg(feature = "arch_msp430")]
mod msp430 {
    //! msp430 sla specifications

    use styx_cpu_type::arch::CpuRegister;

    /// common register translations in TI430Common.sinc
    fn translate_msp430(register: &CpuRegister) -> Box<str> {
        register.name().to_uppercase().into_boxed_str()
    }

    impl crate::SlaRegisters for crate::TiMsp430x {
        fn translate_register(register: &CpuRegister) -> Box<str> {
            translate_msp430(register)
        }
    }

    impl crate::SlaRegisters for crate::TiMsp430 {
        fn translate_register(register: &CpuRegister) -> Box<str> {
            translate_msp430(register)
        }
    }
}

#[cfg(test)]
#[cfg(feature = "arch_arm")]
mod tests {
    use super::*;

    #[test]
    fn test_arm() {
        let name = Arm7Le::name();
        assert_eq!(name, "ARM7_le");
        assert!(!Arm7Le::spec().is_empty());

        assert_eq!(Arm7LeUserOps::JazelleBranch.index(), 41);
    }

    #[test]
    fn test_patch() {
        assert_eq!(Arm7LeUserOps::TestPatch.index(), 62);
    }
}
