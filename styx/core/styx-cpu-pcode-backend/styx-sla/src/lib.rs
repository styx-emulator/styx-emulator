// BSD 2-Clause License
//
// Copyright (c) 2024, Styx Emulator Project
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//! Manages sla specs and provides compiled slas.
//!
//! Provides the following:
//! - Source of truth for slaspec sources.
//! - Apply patches to specs.
//! - Compiled to sla and provided as const static byte slices
//! - Provides generated types for definitions (currently only user ops)
//!
//! ## Sla Specifications
//!
//! Sla specs are located in the `processors/` directory. The
//! `processors/ghidra/` directory is a copy of `Ghidra/Processors/` directory
//! in Ghidra sources. Processor definitions not sourced from Ghidra can be
//! placed under `processors/custom/`
//!
//! ## Patches
//!
//! Patches should be in unified format in the `patches/` folder. The directory
//! folder matches that of the `processors/` folder. The name of the patch file
//! should match the modified file name with the `.patch` extension added. The
//! names of modified files in the patch files are not read.
//!
//! Patches are created using [diffy](https://docs.rs/diffy/latest/diffy/).
//!
//! ### Patches from Github Pull Requests
//!
//! You can get PRs from GitHub in unified diff format by appending `.patch` or
//! `.diff` to the PR URL.
//!
//! For example:
//!
//! ```text
//! https://github.com/styx-emulator/styx-emulator/pull/353
//! https://github.com/styx-emulator/styx-emulator/pull/353.patch
//! https://github.com/styx-emulator/styx-emulator/pull/353.diff
//! ```
//!
//! ### Common Errors
//!
//! If you receive an `failed to apply patch: error applying hunk #n` for your
//! last hunk when building `styx-sla`, check to see if you have a trailing
//! newline. This is required if the final hunk in your patch is not the final
//! line in your patched file.
//!
use styx_cpu_type::arch::CpuRegister;
use styx_pcode::sla::{SlaSpec, SlaUserOps, UserOps};

use derive_more::{Display, FromStr};

// Generated by build.rs
include!(concat!(env!("OUT_DIR"), "/sla_artifacts.rs"));

/// Defines conversion from [CpuRegister] to string for register lookup.
pub trait SlaRegisters {
    /// Return the symbol string in the sla spec corresponding to the given
    /// register. In the majority case this is a lower case conversion from the
    /// [CpuRegister::name()] but individual registers can be matched with
    /// custom names as well.
    fn translate_register(register: &CpuRegister) -> Box<str> {
        register.name().into()
    }
}

#[cfg(feature = "arch_aarch64")]
impl SlaRegisters for Aarch64 {
    fn translate_register(register: &CpuRegister) -> Box<str> {
        // aarch64 sla has all lowercase register names
        register.name().to_lowercase().into_boxed_str()
    }
}

#[cfg(feature = "arch_arm")]
mod arm {
    use styx_cpu_type::arch::CpuRegister;

    /// common to all that use ARM.sinc where registers are defined
    fn translate_arm(register: &CpuRegister) -> Box<str> {
        // arm sla has all lowercase register names
        register.name().to_lowercase().into_boxed_str()
    }

    /// impl [`crate::SlaRegisters`] using [`translate_arm`]
    macro_rules! arm_sla_registers (
        ($p:ty) => {
            impl crate::SlaRegisters for $p {
                fn translate_register(register: &CpuRegister) -> Box<str> {
                    translate_arm(register)
                }
            }
        };
    );

    arm_sla_registers!(crate::Arm7Le);
    arm_sla_registers!(crate::Arm4Be);
    arm_sla_registers!(crate::Arm5Be);
    arm_sla_registers!(crate::Arm6Be);
    arm_sla_registers!(crate::Arm7Be);
    arm_sla_registers!(crate::Arm8Be);

    #[cfg(test)]
    mod tests {
        use crate::{Arm5BeUserOps, Arm7BeUserOps, Arm7LeUserOps};
        use core::str::FromStr;

        #[test]
        fn test_str() {
            assert_eq!(Arm7BeUserOps::Absolute.to_string(), "Absolute");
            assert_eq!(
                Arm7BeUserOps::from_str("Absolute").unwrap(),
                Arm7BeUserOps::Absolute
            );
            assert_eq!(
                Arm5BeUserOps::from_str(&Arm7LeUserOps::Absolute.to_string()).unwrap(),
                Arm5BeUserOps::Absolute
            );
        }
    }
}

#[cfg(feature = "arch_bfin")]
impl SlaRegisters for Blackfin {
    fn translate_register(register: &CpuRegister) -> Box<str> {
        use styx_cpu_type::arch::{
            backends::{ArchRegister, BasicArchRegister},
            blackfin::BlackfinRegister,
        };

        let name = match register.variant() {
            ArchRegister::Basic(BasicArchRegister::Blackfin(BlackfinRegister::A0w)) => "A0.W",
            ArchRegister::Basic(BasicArchRegister::Blackfin(BlackfinRegister::A0x)) => "A0.X",
            ArchRegister::Basic(BasicArchRegister::Blackfin(BlackfinRegister::A1w)) => "A1.W",
            ArchRegister::Basic(BasicArchRegister::Blackfin(BlackfinRegister::A1x)) => "A1.X",
            _ => register.name(),
        };

        // blackfin sla has almost all uppercase register names, we need a special case for the ASTAT flag registers
        if name.contains("flag") {
            name.to_string().into_boxed_str()
        } else {
            name.to_uppercase().into_boxed_str()
        }
    }
}

#[cfg(feature = "arch_superh")]
impl SlaRegisters for SuperH4Be {
    fn translate_register(register: &CpuRegister) -> Box<str> {
        let lower_name = register.name().to_lowercase();

        // some ghidra developer thought they'd be funny
        match lower_name.as_str() {
            "r0b" => "R0_BANK".into(),
            "r1b" => "R1_BANK".into(),
            "r2b" => "R2_BANK".into(),
            "r3b" => "R3_BANK".into(),
            "r4b" => "R4_BANK".into(),
            "r5b" => "R5_BANK".into(),
            "r6b" => "R6_BANK".into(),
            "r7b" => "R7_BANK".into(),
            "gbr" | "sr" | "ssr" | "spc" | "vbr" | "sgr" | "dbr" | "mach" | "macl" | "pr"
            | "pc" | "fpscr" | "fpul" => lower_name.to_uppercase().into_boxed_str(),
            _ => lower_name.into_boxed_str(),
        }
    }
}

#[cfg(feature = "arch_superh")]
impl SlaRegisters for SuperH4Le {
    fn translate_register(register: &CpuRegister) -> Box<str> {
        let lower_name = register.name().to_lowercase();

        // some ghidra developer thought they'd be funny
        match lower_name.as_str() {
            "gbr" | "sr" | "ssr" | "spc" | "vbr" | "sgr" | "dbr" | "mach" | "macl" | "pr"
            | "pc" | "fpscr" | "fpul" => lower_name.to_uppercase().into_boxed_str(),
            _ => lower_name.into_boxed_str(),
        }
    }
}

#[cfg(feature = "arch_superh")]
impl SlaRegisters for Sh1 {
    fn translate_register(register: &CpuRegister) -> Box<str> {
        // all lowercare registers
        register.name().to_lowercase().into_boxed_str()
    }
}

#[cfg(feature = "arch_superh")]
impl SlaRegisters for Sh2 {
    fn translate_register(register: &CpuRegister) -> Box<str> {
        // all lowercare registers
        register.name().to_lowercase().into_boxed_str()
    }
}

#[cfg(feature = "arch_superh")]
impl SlaRegisters for Sh2a {
    fn translate_register(register: &CpuRegister) -> Box<str> {
        // all lowercare registers
        register.name().to_lowercase().into_boxed_str()
    }
}

#[cfg(feature = "arch_ppc")]
#[allow(unused_imports)] // wrong, this is a re-export
pub use ppc::*;
#[cfg(feature = "arch_ppc")]
mod ppc {
    //! PowerPC sla specifications
    //!
    //! Note: ppc_embedded.sinc may have mistakes.
    //!
    //! We've identified one mistake in the implementation of `mtmsr`
    //! instruction where the processor specification follows the "general
    //! processor" PowerISA instead of the embedded specification. If there are
    //! more differences we will construct an entirely new spec based on the
    //! Ghidra spec, instead of applying patches.

    use styx_cpu_type::arch::{
        backends::{ArchRegister, BasicArchRegister, SpecialArchRegister},
        ppc32::{Ppc32Register, SpecialPpc32Register, SprRegister},
        CpuRegister,
    };

    use crate::{Ppc324xxBe, SlaRegisters};

    impl SlaRegisters for Ppc324xxBe {
        fn translate_register(register: &CpuRegister) -> Box<str> {
            let variant = register.variant();

            match variant {
                ArchRegister::Basic(BasicArchRegister::Ppc32(reg)) => ppc32_basic(register, reg),
                ArchRegister::Special(SpecialArchRegister::Ppc32(
                    SpecialPpc32Register::SprRegister(spr),
                )) => ppc32_special(spr),
                _ => "".to_owned().into_boxed_str(),
            }
        }
    }

    fn ppc32_special(spr: SprRegister) -> Box<str> {
        let spr_idx = spr.index();
        format!("spr{spr_idx:03x}").into_boxed_str()
    }

    fn ppc32_basic(register: &CpuRegister, reg: Ppc32Register) -> Box<str> {
        // note, there exists `crall` which you would think is Ppc32Register::CR,
        // however, ghidra represents `crall` as cr0-cr7 each taking a byte, when ppc
        // is actually cr0-cr7 each taking 4 bits. implemented in register handler instead 👍
        match reg {
            Ppc32Register::R0
            | Ppc32Register::R1
            | Ppc32Register::R2
            | Ppc32Register::R3
            | Ppc32Register::R4
            | Ppc32Register::R5
            | Ppc32Register::R6
            | Ppc32Register::R7
            | Ppc32Register::R8
            | Ppc32Register::R9
            | Ppc32Register::R10
            | Ppc32Register::R11
            | Ppc32Register::R12
            | Ppc32Register::R13
            | Ppc32Register::R14
            | Ppc32Register::R15
            | Ppc32Register::R16
            | Ppc32Register::R17
            | Ppc32Register::R18
            | Ppc32Register::R19
            | Ppc32Register::R20
            | Ppc32Register::R21
            | Ppc32Register::R22
            | Ppc32Register::R23
            | Ppc32Register::R24
            | Ppc32Register::R25
            | Ppc32Register::R26
            | Ppc32Register::R27
            | Ppc32Register::R28
            | Ppc32Register::R29
            | Ppc32Register::R30
            | Ppc32Register::R31
            | Ppc32Register::Cr0
            | Ppc32Register::Cr1
            | Ppc32Register::Cr2
            | Ppc32Register::Cr3
            | Ppc32Register::Cr4
            | Ppc32Register::Cr5
            | Ppc32Register::Cr6
            | Ppc32Register::Cr7
            | Ppc32Register::Pc => register.name().to_lowercase(),
            Ppc32Register::TblR => "TBLr".to_owned(),
            Ppc32Register::TbuR => "TBUr".to_owned(),
            Ppc32Register::TblW => "TBLw".to_owned(),
            Ppc32Register::TbuW => "TBUw".to_owned(),
            _ => register.name().to_uppercase(),
        }
        .into_boxed_str()
    }
}

#[cfg(feature = "arch_m32r")]
#[allow(unused_imports)] // wrong, this is a re-export
pub use m32r::*;
#[cfg(feature = "arch_m32r")]
mod m32r {
    //! M32R sla specifications

    use styx_cpu_type::arch::CpuRegister;

    use crate::{M32r, SlaRegisters};

    impl SlaRegisters for M32r {
        fn translate_register(_register: &CpuRegister) -> Box<str> {
            unimplemented!()
        }
    }
}

#[cfg(any(feature = "arch_mips32", feature = "arch_mips64"))]
mod mips_common {
    use styx_cpu_type::arch::{
        backends::{ArchRegister, BasicArchRegister},
        mips32::Mips32Register,
        mips64::Mips64Register,
        CpuRegister,
    };

    pub(crate) fn translate_register(register: &CpuRegister) -> Box<str> {
        match register.variant() {
            // mips.sinc uses names from the O32 abi
            ArchRegister::Basic(BasicArchRegister::Mips32(reg)) => match reg {
                Mips32Register::R0 => "zero",
                Mips32Register::R1 => "at",
                Mips32Register::R2 => "v0",
                Mips32Register::R3 => "v1",
                Mips32Register::R4 => "a0",
                Mips32Register::R5 => "a1",
                Mips32Register::R6 => "a2",
                Mips32Register::R7 => "a3",
                Mips32Register::R8 => "t0",
                Mips32Register::R9 => "t1",
                Mips32Register::R10 => "t2",
                Mips32Register::R11 => "t3",
                Mips32Register::R12 => "t4",
                Mips32Register::R13 => "t5",
                Mips32Register::R14 => "t6",
                Mips32Register::R15 => "t7",
                Mips32Register::R16 => "s0",
                Mips32Register::R17 => "s1",
                Mips32Register::R18 => "s2",
                Mips32Register::R19 => "s3",
                Mips32Register::R20 => "s4",
                Mips32Register::R21 => "s5",
                Mips32Register::R22 => "s6",
                Mips32Register::R23 => "s7",
                Mips32Register::R24 => "t8",
                Mips32Register::R25 => "t9",
                Mips32Register::R26 => "k0",
                Mips32Register::R27 => "k1",
                Mips32Register::R28 => "gp",
                Mips32Register::R29 => "sp",
                Mips32Register::R30 => "s8",
                Mips32Register::R31 => "ra",
                _ => reg.register().name(),
            },
            ArchRegister::Basic(BasicArchRegister::Mips64(reg)) => match reg {
                Mips64Register::R0 => "zero",
                Mips64Register::R1 => "at",
                Mips64Register::R2 => "v0",
                Mips64Register::R3 => "v1",
                Mips64Register::R4 => "a0",
                Mips64Register::R5 => "a1",
                Mips64Register::R6 => "a2",
                Mips64Register::R7 => "a3",
                Mips64Register::R8 => "t0",
                Mips64Register::R9 => "t1",
                Mips64Register::R10 => "t2",
                Mips64Register::R11 => "t3",
                Mips64Register::R12 => "t4",
                Mips64Register::R13 => "t5",
                Mips64Register::R14 => "t6",
                Mips64Register::R15 => "t7",
                Mips64Register::R16 => "s0",
                Mips64Register::R17 => "s1",
                Mips64Register::R18 => "s2",
                Mips64Register::R19 => "s3",
                Mips64Register::R20 => "s4",
                Mips64Register::R21 => "s5",
                Mips64Register::R22 => "s6",
                Mips64Register::R23 => "s7",
                Mips64Register::R24 => "t8",
                Mips64Register::R25 => "t9",
                Mips64Register::R26 => "k0",
                Mips64Register::R27 => "k1",
                Mips64Register::R28 => "gp",
                Mips64Register::R29 => "sp",
                Mips64Register::R30 => "s8",
                Mips64Register::R31 => "ra",
                _ => reg.register().name(),
            },
            _ => "",
        }
        .to_lowercase()
        .into()
    }
}

#[cfg(feature = "arch_mips32")]
mod mips32 {
    //! mips32 sla specifications

    use super::*;

    impl SlaRegisters for Mips32be {
        fn translate_register(register: &CpuRegister) -> Box<str> {
            crate::mips_common::translate_register(register)
        }
    }

    impl SlaRegisters for Mips32le {
        fn translate_register(register: &CpuRegister) -> Box<str> {
            crate::mips_common::translate_register(register)
        }
    }
}

#[cfg(feature = "arch_mips64")]
mod mips64 {
    //! mips64 sla specifications

    use super::*;

    impl SlaRegisters for Mips64be {
        fn translate_register(register: &CpuRegister) -> Box<str> {
            crate::mips_common::translate_register(register)
        }
    }

    impl SlaRegisters for Mips64le {
        fn translate_register(register: &CpuRegister) -> Box<str> {
            crate::mips_common::translate_register(register)
        }
    }
}

#[cfg(feature = "arch_msp430")]
mod msp430 {
    //! msp430 sla specifications

    use styx_cpu_type::arch::CpuRegister;

    /// common register translations in TI430Common.sinc
    fn translate_msp430(register: &CpuRegister) -> Box<str> {
        register.name().to_uppercase().into_boxed_str()
    }

    impl crate::SlaRegisters for crate::TiMsp430x {
        fn translate_register(register: &CpuRegister) -> Box<str> {
            translate_msp430(register)
        }
    }

    impl crate::SlaRegisters for crate::TiMsp430 {
        fn translate_register(register: &CpuRegister) -> Box<str> {
            translate_msp430(register)
        }
    }
}

#[cfg(feature = "arch_hexagon")]
mod hexagon {
    //! hexagon sla specifications

    use styx_cpu_type::arch::{
        backends::{ArchRegister, BasicArchRegister},
        hexagon::HexagonRegister,
        CpuRegister,
    };

    impl crate::SlaRegisters for crate::Hexagon {
        fn translate_register(register: &CpuRegister) -> Box<str> {
            let variant = register.variant();

            match variant {
                ArchRegister::Basic(BasicArchRegister::Hexagon(reg)) => {
                    hexagon_basic(register, reg)
                }
                _ => "".to_owned().into_boxed_str(),
            }
        }
    }

    fn hexagon_basic(register: &CpuRegister, hex_reg: HexagonRegister) -> Box<str> {
        let default_name = register.name();

        // The slaspec doesn't have support for the
        // vector registers at the moment.
        // TODO: Things could get very messy if we update a register name and
        // currently the register is covered in the match fallthrough arm.
        //
        // Eg. if C24 gets named something else in the HexagonRegister struct (defined
        // in macro), then this match will not handle that.
        // I have explicitly redefined all the system and guest registers here for this reason,
        // as in the future we may have names for them, and it would be good for rust to throw an error
        // or have to explicitly modify this match if/when that rename happens.
        (match hex_reg {
            HexagonRegister::Sp => "R29",
            HexagonRegister::Fp => "R30",
            HexagonRegister::Lr => "R31",
            HexagonRegister::D0 => "R1R0",
            HexagonRegister::D1 => "R3R2",
            HexagonRegister::D2 => "R5R4",
            HexagonRegister::D3 => "R7R6",
            HexagonRegister::D4 => "R9R8",
            HexagonRegister::D5 => "R11R10",
            HexagonRegister::D6 => "R13R12",
            HexagonRegister::D7 => "R15R14",
            HexagonRegister::D8 => "R17R16",
            HexagonRegister::D9 => "R19R18",
            HexagonRegister::D10 => "R21R20",
            HexagonRegister::D11 => "R23R22",
            HexagonRegister::D12 => "R25R24",
            HexagonRegister::D13 => "R27R26",
            HexagonRegister::D14 => "R29R28",
            HexagonRegister::D15 => "R31R30",
            HexagonRegister::Sa0 => "C0",
            HexagonRegister::Lc0 => "C1",
            HexagonRegister::Sa1 => "C2",
            HexagonRegister::Lc1 => "C3",
            HexagonRegister::P3_0 => "C4",
            HexagonRegister::C5 => "C5",
            HexagonRegister::M0 => "C6",
            HexagonRegister::M1 => "C7",
            HexagonRegister::Usr => "C8",
            HexagonRegister::Pc => "C9",
            HexagonRegister::Ugp => "C10",
            HexagonRegister::Gp => "C11",
            HexagonRegister::Cs0 => "C12",
            HexagonRegister::Cs1 => "C13",
            HexagonRegister::UpcycleLo => "C14",
            HexagonRegister::UpcycleHi => "C15",
            HexagonRegister::FrameLimit => "C16",
            HexagonRegister::FrameKey => "C17",
            HexagonRegister::PktCountLo => "C18",
            HexagonRegister::PktCountHi => "C19",
            HexagonRegister::EmuPktCount => "C20", // C20, From QEMU definitions: hex_regs.h and cpu.c's hexagon_regnmaes
            HexagonRegister::EmuInsnCount => "C21", // C21, From QEMU: see above
            HexagonRegister::EmuHvxCount => "C22", // C22, From QEMU: see above
            HexagonRegister::UtimerLo => "C30",
            HexagonRegister::UtimerHi => "C31",
            HexagonRegister::Cs => "C13C12",
            HexagonRegister::Upcycle => "C15C14",
            HexagonRegister::C17C16 => "C15C14",
            HexagonRegister::PktCount => "C19C18",
            HexagonRegister::Utimer => "C31C30",
            // For some reason, the slaspec defines S0
            // and S1, but never uses them in any instruction.
            // TODO: patch the slaspec
            HexagonRegister::Sgp0 => "SGP0",
            HexagonRegister::Sgp1 => "SGP1",
            HexagonRegister::Stid => "S2",
            HexagonRegister::Elr => "S3",
            HexagonRegister::BadVa0 => "S4",
            HexagonRegister::BadVa1 => "S5",
            HexagonRegister::Ssr => "S6",
            HexagonRegister::Ccr => "S7",
            HexagonRegister::Htid => "S8",
            HexagonRegister::BadVa => "S9",
            HexagonRegister::Imask => "S10",
            HexagonRegister::S11 => "S11",
            HexagonRegister::S12 => "S12",
            HexagonRegister::S13 => "S13",
            HexagonRegister::S14 => "S14",
            HexagonRegister::S15 => "S15",
            HexagonRegister::Evb => "S16",
            HexagonRegister::ModeCtl => "S17",
            HexagonRegister::SysCfg => "S18",
            HexagonRegister::S19 => "S19",
            HexagonRegister::S20 => "S20",
            HexagonRegister::Vid => "S21",
            HexagonRegister::CfgBase => "S27",
            HexagonRegister::Diag => "S28",
            HexagonRegister::Rev => "S29",
            HexagonRegister::PcycleLo => "S30",
            HexagonRegister::PcycleHi => "S31",
            HexagonRegister::IsdbSt => "S32",
            HexagonRegister::IsdbCfg0 => "S33",
            HexagonRegister::IsdbCfg1 => "S34",
            HexagonRegister::S35 => "S35",
            HexagonRegister::BrkptPc0 => "S36",
            HexagonRegister::BrkptCfg0 => "S37",
            HexagonRegister::BrkptPc1 => "S38",
            HexagonRegister::BrkptCfg1 => "S39",
            HexagonRegister::IsdbMbxIn => "S40",
            HexagonRegister::IsdbMbxOut => "S41",
            HexagonRegister::IsdbEn => "S42",
            HexagonRegister::IsdbGpr => "S43",
            HexagonRegister::S44 => "S44",
            HexagonRegister::S45 => "S45",
            HexagonRegister::S46 => "S46",
            HexagonRegister::S47 => "S47",
            HexagonRegister::PmuCnt0 => "S48",
            HexagonRegister::PmuCnt1 => "S49",
            HexagonRegister::PmuCnt2 => "S50",
            HexagonRegister::PmuCnt3 => "S51",
            HexagonRegister::PmuEvtCfg => "S52",
            HexagonRegister::PmuCfg => "S53",
            HexagonRegister::SGP1SGP0 => "SGP1SGP0",
            HexagonRegister::S3S2
            | HexagonRegister::S5S4
            | HexagonRegister::S7S6
            | HexagonRegister::S9S8
            | HexagonRegister::S11S10
            | HexagonRegister::S13S12
            | HexagonRegister::S15S14
            | HexagonRegister::S17S16
            | HexagonRegister::S19S18
            | HexagonRegister::S21S20
            | HexagonRegister::S23S22
            | HexagonRegister::S25S24
            | HexagonRegister::S27S26
            | HexagonRegister::S29S28
            | HexagonRegister::S31S30
            | HexagonRegister::S33S32
            | HexagonRegister::S35S34
            | HexagonRegister::S37S36
            | HexagonRegister::S39S38
            | HexagonRegister::S41S40
            | HexagonRegister::S43S42
            | HexagonRegister::S45S44
            | HexagonRegister::S47S46
            | HexagonRegister::S49S48
            | HexagonRegister::S51S50
            | HexagonRegister::S53S52
            | HexagonRegister::S55S54
            | HexagonRegister::S57S56
            | HexagonRegister::S59S58
            | HexagonRegister::S61S60
            | HexagonRegister::S63S62
            | HexagonRegister::S65S64
            | HexagonRegister::S67S66
            | HexagonRegister::S69S68
            | HexagonRegister::S71S70
            | HexagonRegister::S73S72
            | HexagonRegister::S75S74
            | HexagonRegister::S77S76
            | HexagonRegister::S79S78 => default_name,
            HexagonRegister::S54
            | HexagonRegister::S55
            | HexagonRegister::S56
            | HexagonRegister::S57
            | HexagonRegister::S58
            | HexagonRegister::S59
            | HexagonRegister::S60
            | HexagonRegister::S61
            | HexagonRegister::S62
            | HexagonRegister::S63
            | HexagonRegister::S64
            | HexagonRegister::S65
            | HexagonRegister::S66
            | HexagonRegister::S67
            | HexagonRegister::S68
            | HexagonRegister::S69
            | HexagonRegister::S70
            | HexagonRegister::S71
            | HexagonRegister::S72
            | HexagonRegister::S73
            | HexagonRegister::S74
            | HexagonRegister::S75
            | HexagonRegister::S76
            | HexagonRegister::S77
            | HexagonRegister::S78
            | HexagonRegister::S79
            | HexagonRegister::S80 => default_name,
            HexagonRegister::Gelr => "G0",
            HexagonRegister::Gsr => "G1",
            HexagonRegister::Gosp => "G2",
            HexagonRegister::G3
            | HexagonRegister::G4
            | HexagonRegister::G5
            | HexagonRegister::G6
            | HexagonRegister::G7
            | HexagonRegister::G8
            | HexagonRegister::G9
            | HexagonRegister::G10
            | HexagonRegister::G11
            | HexagonRegister::G12
            | HexagonRegister::G13
            | HexagonRegister::G14
            | HexagonRegister::G15 => default_name,
            HexagonRegister::Gpmucnt4 => "G16",
            HexagonRegister::Gpmucnt5 => "G17",
            HexagonRegister::Gpmucnt6 => "G18",
            HexagonRegister::Gpmucnt7 => "G19",
            HexagonRegister::Gpcyclelo => "G24",
            HexagonRegister::Gpcyclehi => "G25",
            HexagonRegister::Gpmucnt0 => "G26",
            HexagonRegister::Gpmucnt1 => "G27",
            HexagonRegister::Gpmucnt2 => "G28",
            HexagonRegister::Gpmucnt3 => "G29",
            HexagonRegister::G30 | HexagonRegister::G31 => default_name,
            HexagonRegister::G1G0
            | HexagonRegister::G3G2
            | HexagonRegister::G5G4
            | HexagonRegister::G7G6
            | HexagonRegister::G9G8
            | HexagonRegister::G11G10
            | HexagonRegister::G13G12
            | HexagonRegister::G15G14
            | HexagonRegister::G17G16
            | HexagonRegister::G19G18
            | HexagonRegister::G21G20
            | HexagonRegister::G23G22
            | HexagonRegister::G25G24
            | HexagonRegister::G27G26
            | HexagonRegister::G29G28
            | HexagonRegister::G31G30 => default_name,
            _ => default_name,
        })
        .to_owned()
        .into_boxed_str()
        .into()
    }
}

// TODO: hexagon tests here?

#[cfg(test)]
#[cfg(feature = "arch_arm")]
mod tests {
    use super::*;

    #[test]
    fn test_arm() {
        let name = Arm7Le::name();
        assert_eq!(name, "ARM7_le");
        assert!(!Arm7Le::spec().is_empty());

        assert_eq!(Arm7LeUserOps::JazelleBranch.index(), 41);
    }

    #[test]
    fn test_patch() {
        assert_eq!(Arm7LeUserOps::TestPatch.index(), 62);
    }
}
