// BSD 2-Clause License
//
// Copyright (c) 2024, Styx Emulator Project
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
use iset::IntervalMap;
#[cfg(test)]
use mockall::mock;
use std::any::Any;
use std::borrow::Cow;
use std::collections::HashMap;
use styx_cpu_type::arch::backends::ArchRegister;
use styx_cpu_type::{Arch, ArchEndian};
pub(crate) use styx_errors::styx_loader::StyxLoaderError;
use styx_memory::MemoryRegion;

/// Useful macro to check if a [`LoaderHints`] map contains desired data
///
/// There is 1 implemented pattern that takes 3 arguments:
///
/// - variable containing the [`LoaderHints`] map
/// - expr containing the lookup name of the hint variable
/// - type that the variable should be
///
/// The return is a `Result<Option<$hint_Type>>`. This macro will return
/// an err if the hint variable exists and is the incorrect type.
///
/// ```rust
/// use styx_loader::{LoaderHints, hints_contain};
/// use std::collections::HashMap;
///
/// let mut map: LoaderHints = HashMap::new();
/// _ = map.insert("hello".to_owned().into_boxed_str(), Box::new(String::from("world")));
///
/// assert!(hints_contain!(map, "hello", String).is_ok());
/// assert!(hints_contain!(map, "hello", LoaderHints).is_err());
/// assert_eq!(None, hints_contain!(map, "world", String).unwrap());
/// assert_eq!(&String::from("world"), hints_contain!(map, "hello", String).unwrap().unwrap());
/// ```
///
/// Or more eloquently (example from the elf loader):
/// ```ignore
/// // if an architecture hint was provided, complain if
/// // it's not the same
/// if let Some(arch_hint) = hints_contain!(hints, "arch", Arch)? {
///     if arch_hint != &arch {
///         log::warn!("Parsed Elf arch: `{arch}` is not equal to hinted arch: `{arch_hint}`");
///     }
/// }
/// ```
#[macro_export]
macro_rules! hints_contain {
    ($hint_map:ident, $hint_name:expr_2021, $hint_type:ident) => {
        // check if the map even contains our key
        if let Some((_, value)) = $hint_map.get_key_value($hint_name) {
            // contains our key, now check if the type of the hint is correct
            let maybe_hint_val = value.downcast_ref::<$hint_type>();
            match maybe_hint_val {
                Some(hint_value) => Ok(Some(hint_value)),
                None => Err(::styx_errors::styx_loader::StyxLoaderError::HintType(
                    $hint_name,
                    ::std::any::type_name::<$hint_type>(),
                )),
            }
        } else {
            Ok(None)
        }
    };
}

/// Create hints with processor-specific context and pass to the specified loader. This returns the
/// [`MemoryLoaderDesc`] generated by the loader.
pub fn call_loader_fn(
    loader: &dyn Loader,
    target_program: Cow<[u8]>,
    arch: Arch,
    endian: ArchEndian,
) -> Result<MemoryLoaderDesc, StyxLoaderError> {
    let mut hints: LoaderHints = LoaderHints::new();
    hints.insert(Box::from("arch"), Box::new(arch));
    hints.insert(Box::from("endian"), Box::new(endian));
    loader.load_bytes(target_program, hints)
}

/// Hashmap of hints to help the loader or to provide options / parameters
/// to the loader
pub type LoaderHints = HashMap<Box<str>, Box<dyn Any>>;

pub type RegisterLoaderDesc = (ArchRegister, u64);
pub type EnvStateLoaderDesc = (Box<str>, Box<dyn Any>);

/// Central trait to the [`styx-loader`] crate.
///
/// This trait defines a series of methods used to initialize target address spaces and setup the
/// cpu register and memory as required in order to perform valid cpu emulation of the target
/// software.
///
/// Consumers of this trait need only use [`Loader::load_bytes`] to load the contents of a byte
/// array to a [`MemoryLoaderDesc`]. Inside this method all logic necessary to properly handle the
/// inputs, with optional parameters defined via the [`LoaderHints`] should be contained.
///
/// If any parameters are available / required, they should be documented.
pub trait Loader: std::fmt::Debug + Send {
    /// Returns the name of the [`Loader`]
    fn name(&self) -> &'static str;

    /// The inner implementation of the loader, this is the method that
    /// should actually perform the translation from the data bytes into
    /// a [`MemoryLoaderDesc`].
    fn load_bytes(
        &self,
        data: Cow<[u8]>,
        hints: LoaderHints,
    ) -> Result<MemoryLoaderDesc, StyxLoaderError>;
}

#[cfg(test)]
mock! {
    #[derive(Debug)]
    pub StyxLoader{}

    impl Loader for StyxLoader {
        fn name(&self) -> &'static str;

        fn load_bytes<'a>(
            &self,
            data: Cow<'a, [u8]>,
            hints: LoaderHints,
        ) -> Result<MemoryLoaderDesc, StyxLoaderError>;
    }
}

pub type RegisterMap = HashMap<ArchRegister, u64>;

/// The resulting struct returned from [`Loader::load_bytes`].
///
/// This details the values of registers, memory regions, and state that
/// should be set in the target environment before actually beginning
/// execution
#[derive(Debug, Default)]
pub struct MemoryLoaderDesc {
    /// Any registers that should be set in the target before starting
    /// execution.
    ///
    /// For the moment, if any registers that need to be set are too large
    /// for [`u64`], use [`MemoryLoaderDesc::add_state`] to set them, and
    /// please make an issue on the git repo.
    registers: RegisterMap,

    /// List of regions that have been parsed by the [`Loader`] in question.
    ///
    /// All regions in this vec should have applicable base addresses and
    /// sizes populated, and should be ready for use.
    memory_regions: IntervalMap<u64, MemoryRegion>,

    /// Holds any state that is necessary to load the firmware file that has
    /// been passed to the backing loader. Eg. sometimes it is possible to
    /// get target hints from parsing firmware files, or versions etc.
    env_state: LoaderHints,
}

impl MemoryLoaderDesc {
    /// Take ownership of the registers and their values that
    /// should be set
    ///
    /// ```rust
    /// use styx_loader::MemoryLoaderDesc;
    /// use styx_cpu_type::arch::{backends::{ArchRegister, BasicArchRegister}, arm::ArmRegister};
    ///
    /// let r1 = ArmRegister::R1;
    ///
    /// let mut desc = MemoryLoaderDesc::default();
    /// assert!(desc.add_register(r1, 0x41414141).is_ok(), "Failed to add R1");
    ///
    /// let registers = desc.take_registers();
    /// assert_eq!(1, registers.len(), "Length of registers is not 1");
    /// assert_eq!(ArchRegister::Basic(BasicArchRegister::Arm(ArmRegister::R1)), registers[0].0, "Returned register is not R1");
    /// assert_eq!(0x41414141, registers[0].1, "Content of R1 is not `0x41414141`");
    /// ```
    pub fn take_registers(&mut self) -> Vec<RegisterLoaderDesc> {
        self.registers.drain().collect()
    }

    /// Take ownership of the memory regions to be populated
    ///
    /// ```rust
    /// use styx_loader::MemoryLoaderDesc;
    /// use styx_memory::MemoryRegion;
    /// # use styx_memory::MemoryPermissions;
    /// # let all_perms = MemoryPermissions::all();
    /// let r1 = MemoryRegion::new(0x1000, 0x100, all_perms).unwrap();
    ///
    /// let mut desc = MemoryLoaderDesc::default();
    /// assert!(desc.add_region(r1).is_ok(), "Failed to add region");
    ///
    /// let regions = desc.take_memory_regions();
    /// assert_eq!(1, regions.len(), "Length of regions is not 1");
    /// assert_eq!(0x1000, regions[0].base(), "Region base is incorrect");
    /// assert_eq!(0x100, regions[0].size(), "Region size is incorrect");
    /// ```
    pub fn take_memory_regions(&mut self) -> Vec<MemoryRegion> {
        // self.memory_regions.into_values(query) seems more appropriate but
        // does not operate as expected.

        // instead we just remove regions one by one
        let regions = &mut self.memory_regions;
        let mut return_regions = Vec::with_capacity(regions.len());
        while let Some(region) = regions.remove_largest() {
            return_regions.push(region.1);
        }

        return_regions
    }

    /// Provides a read only access to the [`Vec<MemoryRegion>`] contained
    /// in the description
    ///
    /// ```rust
    /// use styx_loader::MemoryLoaderDesc;
    /// use styx_memory::MemoryRegion;
    /// # use styx_memory::MemoryPermissions;
    /// # let all_perms = MemoryPermissions::all();
    /// let r1 = MemoryRegion::new(0x1000, 0x100, all_perms).unwrap();
    ///
    /// let mut desc = MemoryLoaderDesc::default();
    /// assert!(desc.add_region(r1).is_ok(), "Failed to add region");
    ///
    /// let regions = desc.regions().collect::<Vec<_>>();
    /// assert_eq!(1, regions.len(), "Length of regions is not 1");
    /// assert_eq!(0x1000, regions[0].base(), "Region base is incorrect");
    /// assert_eq!(0x100, regions[0].size(), "Region size is incorrect");
    /// ```
    pub fn regions(&self) -> LoaderRegionIter {
        LoaderRegionIter {
            regions: self.memory_regions.values(..),
        }
    }

    /// Provides mutable access to the [`Vec<MemoryRegion>`] contained
    /// in the description
    ///
    /// ```rust
    /// use styx_loader::MemoryLoaderDesc;
    /// use styx_memory::MemoryRegion;
    /// # use styx_memory::MemoryPermissions;
    /// # let all_perms = MemoryPermissions::all();
    /// let r1 = MemoryRegion::new(0x1000, 0x100, all_perms).unwrap();
    ///
    /// let mut desc = MemoryLoaderDesc::default();
    /// assert!(desc.add_region(r1).is_ok(), "Failed to add region");
    ///
    /// let mut regions = desc.regions_mut().collect::<Vec<_>>();
    /// assert_eq!(1, regions.len(), "Length of regions is not 1");
    /// assert_eq!(0x1000, regions[0].base(), "Region base is incorrect");
    /// assert_eq!(0x100, regions[0].size(), "Region size is incorrect");
    /// unsafe {
    ///     regions[0].rebase(0x9999);
    /// }
    /// assert_eq!(0x9999, regions[0].base(), "Region base is incorrect after mutation");
    /// ```
    pub fn regions_mut(&mut self) -> LoaderRegionIterMut {
        LoaderRegionIterMut {
            regions: self.memory_regions.values_mut(..),
        }
    }

    /// Take ownership of the state variables that should be
    /// set
    ///
    /// ```rust
    /// use styx_loader::MemoryLoaderDesc;
    ///
    /// let var1 = Box::new("hello world".to_owned());
    ///
    /// let mut desc = MemoryLoaderDesc::default();
    /// assert!(desc.add_state("var1", var1).is_ok(), "Failed to add var1");
    ///
    /// let state_vars = desc.take_env_state();
    /// assert_eq!(1, state_vars.len(), "Length of state vars is not 1");
    /// assert_eq!("var1", &*state_vars[0].0, "Name of state var is not `var1`");
    /// ```
    pub fn take_env_state(&mut self) -> Vec<EnvStateLoaderDesc> {
        self.env_state.drain().collect()
    }

    /// Adds an arbitrary environment state variable to the loader description.
    ///
    /// Before adding the variable to the collection, the name of the variable
    /// is checked for duplicates.
    ///
    /// ```rust
    /// use styx_loader::MemoryLoaderDesc;
    /// use styx_cpu_type::arch::{backends::ArchRegister, arm::ArmRegister};
    ///
    /// let r1 = ArmRegister::R1;
    /// let r1_too = ArmRegister::R1;
    ///
    /// let mut desc = MemoryLoaderDesc::default();
    /// assert!(desc.add_register(r1, 0x41414141).is_ok(), "Failed to add R1");
    /// assert!(desc.add_register(r1_too, 0xDEADBEEF).is_err(), "Failed to detect duplicate register");
    /// ```
    pub fn add_register(
        &mut self,
        reg: impl Into<ArchRegister>,
        value: u64,
    ) -> Result<(), DuplicateRegister> {
        let register = reg.into();

        if self.registers.contains_key(&register) {
            return Err(DuplicateRegister(register));
        }

        _ = self.registers.insert(register, value);
        Ok(())
    }

    /// Adds an arbitrary environment state variable to the loader description.
    ///
    /// Before adding the variable to the collection, the name of the variable
    /// is checked for duplicates.
    ///
    /// ```rust
    /// use styx_loader::MemoryLoaderDesc;
    ///
    /// let var1 = Box::new("hello world".to_owned());
    /// let var2 = Box::new("hello".to_owned());
    ///
    /// let mut desc = MemoryLoaderDesc::default();
    /// assert!(desc.add_state("var1", var1).is_ok(), "Failed to add var1");
    /// assert!(desc.add_state("var1", var2).is_err(), "Failed to detect duplicate state");
    /// ```
    pub fn add_state(
        &mut self,
        state: &'static str,
        value: Box<dyn Any>,
    ) -> Result<(), DuplicateState> {
        if self.env_state.contains_key(state) {
            return Err(DuplicateState(state));
        }

        _ = self.env_state.insert(Box::from(state), value);
        Ok(())
    }

    /// Adds a [`MemoryRegion`] to the loader description.
    ///
    /// Before adding the region to the collection, the base address and
    /// size of the region (but *not* the contents) are checked for duplicates.
    ///
    /// ```rust
    /// use styx_loader::MemoryLoaderDesc;
    /// use styx_memory::MemoryRegion;
    /// # use styx_memory::MemoryPermissions;
    /// # let all = MemoryPermissions::all();
    /// let r1 = MemoryRegion::new(0x1000, 0x100, all).unwrap();
    /// let r2 = MemoryRegion::new(0x1000, 0x100, all).unwrap();
    ///
    /// let mut desc = MemoryLoaderDesc::default();
    /// assert!(desc.add_region(r1).is_ok(), "Failed to add region");
    /// assert!(desc.add_region(r2).is_err(), "Failed to detect duplicate region");
    /// ```
    pub fn add_region(&mut self, region: MemoryRegion) -> Result<(), DuplicateRegion> {
        let range = region.base()..(region.base() + region.size());
        if self.memory_regions.has_overlap(range.clone()) {
            return Err(DuplicateRegion {
                base: region.base(),
                size: region.size(),
            });
        }

        self.memory_regions.insert(range, region);
        Ok(())
    }

    /// Create a new [`MemoryLoaderDesc`] with an initial set of regions
    ///
    /// ```rust
    /// use styx_loader::MemoryLoaderDesc;
    /// use styx_memory::MemoryRegion;
    /// # use styx_memory::MemoryPermissions;
    /// # let all = MemoryPermissions::all();
    /// let r1 = MemoryRegion::new(0x1000, 0x100, all).unwrap();
    /// let r2 = MemoryRegion::new(0x1100, 0x100, all).unwrap();
    /// let regions = vec![r1, r2];
    ///
    /// let mut desc = MemoryLoaderDesc::with_regions(regions).unwrap();
    /// # let regions = desc.take_memory_regions();
    /// # assert_eq!(2, regions.len(), "Length of regions is not 1");
    /// # assert_eq!(0x1100, regions[0].base(), "Region 0 base is incorrect");
    /// # assert_eq!(0x100, regions[0].size(), "Region 0 size is incorrect");
    /// # assert_eq!(0x1000, regions[1].base(), "Region 1 base is incorrect");
    /// # assert_eq!(0x100, regions[1].size(), "Region 1 size is incorrect");
    /// ```
    pub fn with_regions(mut regions: Vec<MemoryRegion>) -> Result<Self, DuplicateRegion> {
        let mut desc = MemoryLoaderDesc::default();

        // add all the regions
        while let Some(region) = regions.pop() {
            desc.add_region(region)?;
        }

        // return the constructed description
        Ok(desc)
    }
}

#[derive(thiserror::Error, Debug)]
#[error("duplicate register: {0}")]
pub struct DuplicateRegister(pub ArchRegister);

#[derive(thiserror::Error, Debug)]
#[error("duplicate state: {0}")]
pub struct DuplicateState(pub &'static str);

#[derive(thiserror::Error, Debug)]
#[error("duplicate region: base={base} size={size}")]
pub struct DuplicateRegion {
    pub base: u64,
    pub size: u64,
}

/// Iterates over [MemoryRegion]s in a [MemoryLoaderDesc].
///
/// Use [MemoryLoaderDesc::regions()] to obtain.
#[derive(Debug)]
pub struct LoaderRegionIter<'a> {
    regions: iset::iter::Values<'a, u64, MemoryRegion, std::ops::RangeFull, u32>,
}

impl<'a> Iterator for LoaderRegionIter<'a> {
    type Item = &'a MemoryRegion;

    fn next(&mut self) -> Option<Self::Item> {
        self.regions.next()
    }
}

/// Iterates mutably over [MemoryRegion]s in a [MemoryLoaderDesc].
///
/// Use [MemoryLoaderDesc::regions_mut()] to obtain.
#[derive(Debug)]
pub struct LoaderRegionIterMut<'a> {
    regions: iset::iter::ValuesMut<'a, u64, MemoryRegion, std::ops::RangeFull, u32>,
}

impl<'a> Iterator for LoaderRegionIterMut<'a> {
    type Item = &'a mut MemoryRegion;

    fn next(&mut self) -> Option<Self::Item> {
        self.regions.next()
    }
}

mod loaders;
pub use loaders::*;

#[cfg(test)]
mod tests {
    use styx_memory::MemoryPermissions;

    use super::*;

    /// Tests adding a mutually exclusive region, same region, and overlapping
    /// region to a [MemoryLoaderDesc].
    #[test]
    fn test_add_region() {
        let mut desc = MemoryLoaderDesc::default();
        // region1 and region2 are mutally exclusive
        let region1 = MemoryRegion::new(0, 10, MemoryPermissions::all()).unwrap();
        let region2 = MemoryRegion::new(10, 20, MemoryPermissions::all()).unwrap();
        // exact same as region2
        let region2_overlap_exact = MemoryRegion::new(10, 20, MemoryPermissions::all()).unwrap();
        // overlaps region2
        let region2_overlap_roughly = MemoryRegion::new(12, 22, MemoryPermissions::all()).unwrap();

        assert!(desc.add_region(region1).is_ok());
        assert!(desc.add_region(region2).is_ok());
        assert!(matches!(
            desc.add_region(region2_overlap_exact),
            Err(DuplicateRegion { base: 10, size: 20 })
        ));
        assert!(matches!(
            desc.add_region(region2_overlap_roughly),
            Err(DuplicateRegion { base: 12, size: 22 })
        ));
    }
}
