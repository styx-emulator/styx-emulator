// SPDX-License-Identifier: BSD-2-Clause
//! Benchmarks the Unicorn and Pcode backends on PowerPc execution.
//!
//! Provide a firmware path and their execution times will be compared and reported.
//!
//! - Run all benchmarks
//!   - `cargo bench --package styx-emulator --bench pcode_vs_unicorn_ppc`
//! - Run single benchmark (replace `pcode` with filter)
//!   - `cargo bench --package styx-emulator --bench pcode_vs_unicorn_ppc -- pcode`
//! - Save a baseline and then compares against it later
//!   - `cargo bench --package styx-emulator --bench pcode_vs_unicorn_ppc -- pcode
//!     --save-baseline base`
//!   - `cargo bench --package styx-emulator --bench pcode_vs_unicorn_ppc -- pcode --baseline
//!     base`
//! - Generate a flame graph of function calls to find performance culprits
//!   - `cargo install flamegraph # only needed once`
//!   - `cargo flamegraph --package styx-emulator --bench pcode_vs_unicorn_ppc -- --bench --profile-time 5
//!     pcode`

use criterion::{criterion_group, criterion_main, Criterion};
use styx_emulator::arch::ppc32::Ppc32Register;
use styx_emulator::cpu::arch::ppc32::Ppc32Variants;
use styx_emulator::loader::ElfLoader;
use styx_emulator::prelude::*;
use styx_emulator::processors::RawProcessor;
use tracing::{debug, info};

fn build(backend: Backend, firmware: impl Into<String>) -> Processor {
    // build the processor!
    let proc_builder = ProcessorBuilder::default()
        .with_builder(RawProcessor::new(
            Arch::Ppc32,
            Ppc32Variants::Ppc405,
            ArchEndian::BigEndian,
        ))
        .with_backend(backend)
        .with_loader(ElfLoader::default())
        .with_target_program(firmware);

    let mut proc = proc_builder.build().unwrap();

    // Add a code hook to automatically stop when we hit the infinite loop
    // at the end of the benchmark.
    proc.add_hook(StyxHook::code(.., |proc: CoreHandle| {
        // Either of these are probable "infinite loop" instructions
        let stop_instructions = [
            0x4bfffffcu32, // b pc-1
            0x48000000u32, // b pc ; generated by -O3
        ]
        .map(|instr| instr.to_be_bytes());
        let mut stop_instructions = stop_instructions.iter().map(|bytes| bytes.as_slice());

        let pc = proc.cpu.pc().unwrap();
        let mut current_instruction = [0u8; 4];
        proc.mmu.code().read(pc).bytes(&mut current_instruction)?;
        if stop_instructions.any(|instr| instr == current_instruction) {
            debug!("Found infinite loop, stopping");
            proc.cpu.stop();
        }
        Ok(())
    }))
    .unwrap();

    proc
}

fn run(proc: &mut Processor) {
    let res = proc.run(Forever).unwrap();
    assert_eq!(res.exit_reason, TargetExitReason::HostStopRequest);
    let pc = proc.core.pc().unwrap();
    info!("Stopped at PC: 0x{:x}", pc);

    // r15 holds result of calculation
    let r15 = proc
        .core
        .cpu
        .read_register::<u32>(Ppc32Register::R15)
        .unwrap();

    // Print result
    info!("Result: {r15}");
}

fn reset(proc: &mut Processor) {
    proc.core.set_pc(0x100).unwrap();
}

fn criterion_benchmark(c: &mut Criterion) {
    let firmware_path = &styx_emulator::core::util::resolve_test_bin("ppc/fib/fib");
    info!("Loading firmware from {:?}", firmware_path);

    let mut group = c.benchmark_group("fib");
    group.bench_function("pcode", |b| {
        let mut proc = build(Backend::Pcode, firmware_path);
        b.iter(|| {
            run(&mut proc);
            reset(&mut proc);
        })
    });
    group.bench_function("unicorn", |b| {
        let mut proc = build(Backend::Unicorn, firmware_path);
        b.iter(|| {
            run(&mut proc);
            reset(&mut proc);
        })
    });

    group.finish();
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
