// SPDX-License-Identifier: BSD-2-Clause
#![doc = "Peripheral access API for HPS microcontrollers (generated using svd2rust v0.32.0 (8fe79e6 2024-02-26))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.32.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
use core::marker::PhantomData;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[doc = "Address space allocated to the STM. For detailed information about the use of this address space, [url=http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0444b/index.html]click here[/url]
to access the ARM documentation for the CoreSight STM-101."]
#[cfg(feature = "stm")]
pub struct Stm {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "stm")]
unsafe impl Send for Stm {}
#[cfg(feature = "stm")]
impl Stm {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xfc00_0000;
}
#[doc = "Address space allocated to the STM. For detailed information about the use of this address space, \\[url=http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0444b/index.html\\]click here\\[/url\\]
to access the ARM documentation for the CoreSight STM-101."]
#[cfg(feature = "stm")]
pub mod stm;
#[doc = "Address space allocated to the DAP. For detailed information about the use of this address space, [url=http://infocenter.arm.com/help/topic/com.arm.doc.ddi0314h/index.html]click here[/url]
to access the ARM documentation for the DAP."]
#[cfg(feature = "dap")]
pub struct Dap {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "dap")]
unsafe impl Send for Dap {}
#[cfg(feature = "dap")]
impl Dap {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xff00_0000;
}
#[doc = "Address space allocated to the DAP. For detailed information about the use of this address space, \\[url=http://infocenter.arm.com/help/topic/com.arm.doc.ddi0314h/index.html\\]click here\\[/url\\]
to access the ARM documentation for the DAP."]
#[cfg(feature = "dap")]
pub mod dap;
#[doc = "Registers in the LWHPS2FPGA AXI Bridge Module."]
#[cfg(feature = "lwhps2fpgaregs")]
pub struct Lwhps2fpgaregs {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "lwhps2fpgaregs")]
unsafe impl Send for Lwhps2fpgaregs {}
#[cfg(feature = "lwhps2fpgaregs")]
impl Lwhps2fpgaregs {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xff40_0000;
}
#[doc = "Registers in the LWHPS2FPGA AXI Bridge Module."]
#[cfg(feature = "lwhps2fpgaregs")]
pub mod lwhps2fpgaregs;
#[doc = "Registers in the HPS2FPGA AXI Bridge Module."]
#[cfg(feature = "hps2fpgaregs")]
pub struct Hps2fpgaregs {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "hps2fpgaregs")]
unsafe impl Send for Hps2fpgaregs {}
#[cfg(feature = "hps2fpgaregs")]
impl Hps2fpgaregs {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xff50_0000;
}
#[doc = "Registers in the HPS2FPGA AXI Bridge Module."]
#[cfg(feature = "hps2fpgaregs")]
pub mod hps2fpgaregs;
#[doc = "Registers in the FPGA2HPS AXI Bridge Module."]
#[cfg(feature = "fpga2hpsregs")]
pub struct Fpga2hpsregs {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "fpga2hpsregs")]
unsafe impl Send for Fpga2hpsregs {}
#[cfg(feature = "fpga2hpsregs")]
impl Fpga2hpsregs {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xff60_0000;
}
#[doc = "Registers in the FPGA2HPS AXI Bridge Module."]
#[cfg(feature = "fpga2hpsregs")]
pub mod fpga2hpsregs;
#[doc = "Registers in the EMAC module."]
#[cfg(feature = "emac0")]
pub struct Emac0 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "emac0")]
unsafe impl Send for Emac0 {}
#[cfg(feature = "emac0")]
impl Emac0 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xff70_0000;
}
#[doc = "Registers in the EMAC module."]
#[cfg(feature = "emac0")]
pub mod emac0;
#[doc = "Registers in the EMAC module."]
#[cfg(feature = "emac1")]
pub struct Emac1 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "emac1")]
unsafe impl Send for Emac1 {}
#[cfg(feature = "emac1")]
impl Emac1 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xff70_2000;
}
#[doc = "Registers in the EMAC module."]
#[cfg(feature = "emac1")]
pub mod emac1;
#[doc = "Registers in the SD/MMC module"]
#[cfg(feature = "sdmmc")]
pub struct Sdmmc {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "sdmmc")]
unsafe impl Send for Sdmmc {}
#[cfg(feature = "sdmmc")]
impl Sdmmc {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xff70_4000;
}
#[doc = "Registers in the SD/MMC module"]
#[cfg(feature = "sdmmc")]
pub mod sdmmc;
#[doc = "Registers in the QSPI Flash Controller module accessible via its APB slave"]
#[cfg(feature = "qspiregs")]
pub struct Qspiregs {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "qspiregs")]
unsafe impl Send for Qspiregs {}
#[cfg(feature = "qspiregs")]
impl Qspiregs {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xff70_5000;
}
#[doc = "Registers in the QSPI Flash Controller module accessible via its APB slave"]
#[cfg(feature = "qspiregs")]
pub mod qspiregs;
#[doc = "Registers in the FPGA Manager module accessible via its APB slave"]
#[cfg(feature = "fpgamgrregs")]
pub struct Fpgamgrregs {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "fpgamgrregs")]
unsafe impl Send for Fpgamgrregs {}
#[cfg(feature = "fpgamgrregs")]
impl Fpgamgrregs {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xff70_6000;
}
#[doc = "Registers in the FPGA Manager module accessible via its APB slave"]
#[cfg(feature = "fpgamgrregs")]
pub mod fpgamgrregs;
#[doc = "Registers in the ACP ID Mapper module"]
#[cfg(feature = "acpidmap")]
pub struct Acpidmap {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "acpidmap")]
unsafe impl Send for Acpidmap {}
#[cfg(feature = "acpidmap")]
impl Acpidmap {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xff70_7000;
}
#[doc = "Registers in the ACP ID Mapper module"]
#[cfg(feature = "acpidmap")]
pub mod acpidmap;
#[doc = "Registers in the GPIO module"]
#[cfg(feature = "gpio0")]
pub struct Gpio0 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "gpio0")]
unsafe impl Send for Gpio0 {}
#[cfg(feature = "gpio0")]
impl Gpio0 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xff70_8000;
}
#[doc = "Registers in the GPIO module"]
#[cfg(feature = "gpio0")]
pub mod gpio0;
#[doc = "Registers in the GPIO module"]
#[cfg(feature = "gpio1")]
pub struct Gpio1 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "gpio1")]
unsafe impl Send for Gpio1 {}
#[cfg(feature = "gpio1")]
impl Gpio1 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xff70_9000;
}
#[doc = "Registers in the GPIO module"]
#[cfg(feature = "gpio1")]
pub mod gpio1;
#[doc = "Registers in the GPIO module"]
#[cfg(feature = "gpio2")]
pub struct Gpio2 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "gpio2")]
unsafe impl Send for Gpio2 {}
#[cfg(feature = "gpio2")]
impl Gpio2 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xff70_a000;
}
#[doc = "Registers in the GPIO module"]
#[cfg(feature = "gpio2")]
pub mod gpio2;
#[doc = "Registers to control L3 interconnect settings"]
#[cfg(feature = "l3regs")]
pub struct L3regs {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "l3regs")]
unsafe impl Send for L3regs {}
#[cfg(feature = "l3regs")]
impl L3regs {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xff80_0000;
}
#[doc = "Registers to control L3 interconnect settings"]
#[cfg(feature = "l3regs")]
pub mod l3regs;
#[doc = "Registers in the USB OTG Controller Module. Only the Core Global, Power and Clock Gating, Data FIFO Access, and Host Port registers can be accessedin both Host and Device modes. When the USB OTG Controller is operating in one mode, either Device or Host, the application must not access registers from the other mode. If an illegal access occurs, a Mode Mismatch interrupt is generated and reflected in the Core Interrupt register (GINTSTS.ModeMis). When the core switches from one mode to another, the registers in the new mode must be reprogrammed as they would be after a power-on reset. The register address map is fixed and does not depend on the module configuration (for example, how many endpoints are implemented). Host and Device mode registers occupy different addresses."]
#[cfg(feature = "usb0")]
pub struct Usb0 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "usb0")]
unsafe impl Send for Usb0 {}
#[cfg(feature = "usb0")]
impl Usb0 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffb0_0000;
}
#[doc = "Registers in the USB OTG Controller Module. Only the Core Global, Power and Clock Gating, Data FIFO Access, and Host Port registers can be accessedin both Host and Device modes. When the USB OTG Controller is operating in one mode, either Device or Host, the application must not access registers from the other mode. If an illegal access occurs, a Mode Mismatch interrupt is generated and reflected in the Core Interrupt register (GINTSTS.ModeMis). When the core switches from one mode to another, the registers in the new mode must be reprogrammed as they would be after a power-on reset. The register address map is fixed and does not depend on the module configuration (for example, how many endpoints are implemented). Host and Device mode registers occupy different addresses."]
#[cfg(feature = "usb0")]
pub mod usb0;
#[doc = "Registers in the USB OTG Controller Module. Only the Core Global, Power and Clock Gating, Data FIFO Access, and Host Port registers can be accessedin both Host and Device modes. When the USB OTG Controller is operating in one mode, either Device or Host, the application must not access registers from the other mode. If an illegal access occurs, a Mode Mismatch interrupt is generated and reflected in the Core Interrupt register (GINTSTS.ModeMis). When the core switches from one mode to another, the registers in the new mode must be reprogrammed as they would be after a power-on reset. The register address map is fixed and does not depend on the module configuration (for example, how many endpoints are implemented). Host and Device mode registers occupy different addresses."]
#[cfg(feature = "usb1")]
pub struct Usb1 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "usb1")]
unsafe impl Send for Usb1 {}
#[cfg(feature = "usb1")]
impl Usb1 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffb4_0000;
}
#[doc = "Registers in the USB OTG Controller Module. Only the Core Global, Power and Clock Gating, Data FIFO Access, and Host Port registers can be accessedin both Host and Device modes. When the USB OTG Controller is operating in one mode, either Device or Host, the application must not access registers from the other mode. If an illegal access occurs, a Mode Mismatch interrupt is generated and reflected in the Core Interrupt register (GINTSTS.ModeMis). When the core switches from one mode to another, the registers in the new mode must be reprogrammed as they would be after a power-on reset. The register address map is fixed and does not depend on the module configuration (for example, how many endpoints are implemented). Host and Device mode registers occupy different addresses."]
#[cfg(feature = "usb1")]
pub mod usb1;
#[doc = "Registers in the NAND Flash Controller module accessible via its register AXI slave"]
#[cfg(feature = "nandregs")]
pub struct Nandregs {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "nandregs")]
unsafe impl Send for Nandregs {}
#[cfg(feature = "nandregs")]
impl Nandregs {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffb8_0000;
}
#[doc = "Registers in the NAND Flash Controller module accessible via its register AXI slave"]
#[cfg(feature = "nandregs")]
pub mod nandregs;
#[doc = "Registers in the FPGA Manager module accessible via its AXI slave"]
#[cfg(feature = "fpgamgrdata")]
pub struct Fpgamgrdata {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "fpgamgrdata")]
unsafe impl Send for Fpgamgrdata {}
#[cfg(feature = "fpgamgrdata")]
impl Fpgamgrdata {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffb9_0000;
}
#[doc = "Registers in the FPGA Manager module accessible via its AXI slave"]
#[cfg(feature = "fpgamgrdata")]
pub mod fpgamgrdata;
#[doc = "Registers in the CAN Controller module NOTE: These descriptions apply only to SoC devices that support the CAN module."]
#[cfg(feature = "can0")]
pub struct Can0 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "can0")]
unsafe impl Send for Can0 {}
#[cfg(feature = "can0")]
impl Can0 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffc0_0000;
}
#[doc = "Registers in the CAN Controller module NOTE: These descriptions apply only to SoC devices that support the CAN module."]
#[cfg(feature = "can0")]
pub mod can0;
#[doc = "Registers in the CAN Controller module NOTE: These descriptions apply only to SoC devices that support the CAN module."]
#[cfg(feature = "can1")]
pub struct Can1 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "can1")]
unsafe impl Send for Can1 {}
#[cfg(feature = "can1")]
impl Can1 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffc0_1000;
}
#[doc = "Registers in the CAN Controller module NOTE: These descriptions apply only to SoC devices that support the CAN module."]
#[cfg(feature = "can1")]
pub mod can1;
#[doc = "Registers in the UART module"]
#[cfg(feature = "uart0")]
pub struct Uart0 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "uart0")]
unsafe impl Send for Uart0 {}
#[cfg(feature = "uart0")]
impl Uart0 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffc0_2000;
}
#[doc = "Registers in the UART module"]
#[cfg(feature = "uart0")]
pub mod uart0;
#[doc = "Registers in the UART module"]
#[cfg(feature = "uart1")]
pub struct Uart1 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "uart1")]
unsafe impl Send for Uart1 {}
#[cfg(feature = "uart1")]
impl Uart1 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffc0_3000;
}
#[doc = "Registers in the UART module"]
#[cfg(feature = "uart1")]
pub mod uart1;
#[doc = "Registers in the I2C module"]
#[cfg(feature = "i2c0")]
pub struct I2c0 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "i2c0")]
unsafe impl Send for I2c0 {}
#[cfg(feature = "i2c0")]
impl I2c0 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffc0_4000;
}
#[doc = "Registers in the I2C module"]
#[cfg(feature = "i2c0")]
pub mod i2c0;
#[doc = "Registers in the I2C module"]
#[cfg(feature = "i2c1")]
pub struct I2c1 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "i2c1")]
unsafe impl Send for I2c1 {}
#[cfg(feature = "i2c1")]
impl I2c1 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffc0_5000;
}
#[doc = "Registers in the I2C module"]
#[cfg(feature = "i2c1")]
pub mod i2c1;
#[doc = "Registers in the I2C module"]
#[cfg(feature = "i2c2")]
pub struct I2c2 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "i2c2")]
unsafe impl Send for I2c2 {}
#[cfg(feature = "i2c2")]
impl I2c2 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffc0_6000;
}
#[doc = "Registers in the I2C module"]
#[cfg(feature = "i2c2")]
pub mod i2c2;
#[doc = "Registers in the I2C module"]
#[cfg(feature = "i2c3")]
pub struct I2c3 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "i2c3")]
unsafe impl Send for I2c3 {}
#[cfg(feature = "i2c3")]
impl I2c3 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffc0_7000;
}
#[doc = "Registers in the I2C module"]
#[cfg(feature = "i2c3")]
pub mod i2c3;
#[doc = "Registers in the timer module. The timer IP core supports multiple timers but it is configured for just one timer. The term Timer1 refers to this one timer in the IP core and not the module instance."]
#[cfg(feature = "sptimer0")]
pub struct Sptimer0 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "sptimer0")]
unsafe impl Send for Sptimer0 {}
#[cfg(feature = "sptimer0")]
impl Sptimer0 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffc0_8000;
}
#[doc = "Registers in the timer module. The timer IP core supports multiple timers but it is configured for just one timer. The term Timer1 refers to this one timer in the IP core and not the module instance."]
#[cfg(feature = "sptimer0")]
pub mod sptimer0;
#[doc = "Registers in the timer module. The timer IP core supports multiple timers but it is configured for just one timer. The term Timer1 refers to this one timer in the IP core and not the module instance."]
#[cfg(feature = "sptimer1")]
pub struct Sptimer1 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "sptimer1")]
unsafe impl Send for Sptimer1 {}
#[cfg(feature = "sptimer1")]
impl Sptimer1 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffc0_9000;
}
#[doc = "Registers in the timer module. The timer IP core supports multiple timers but it is configured for just one timer. The term Timer1 refers to this one timer in the IP core and not the module instance."]
#[cfg(feature = "sptimer1")]
pub mod sptimer1;
#[doc = "Address map for the SDRAM Interface registers"]
#[cfg(feature = "sdr")]
pub struct Sdr {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "sdr")]
unsafe impl Send for Sdr {}
#[cfg(feature = "sdr")]
impl Sdr {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffc2_0000;
}
#[doc = "Address map for the SDRAM Interface registers"]
#[cfg(feature = "sdr")]
pub mod sdr;
#[doc = "Registers in the timer module. The timer IP core supports multiple timers but it is configured for just one timer. The term Timer1 refers to this one timer in the IP core and not the module instance."]
#[cfg(feature = "osc1timer0")]
pub struct Osc1timer0 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "osc1timer0")]
unsafe impl Send for Osc1timer0 {}
#[cfg(feature = "osc1timer0")]
impl Osc1timer0 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffd0_0000;
}
#[doc = "Registers in the timer module. The timer IP core supports multiple timers but it is configured for just one timer. The term Timer1 refers to this one timer in the IP core and not the module instance."]
#[cfg(feature = "osc1timer0")]
pub mod osc1timer0;
#[doc = "Registers in the timer module. The timer IP core supports multiple timers but it is configured for just one timer. The term Timer1 refers to this one timer in the IP core and not the module instance."]
#[cfg(feature = "osc1timer1")]
pub struct Osc1timer1 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "osc1timer1")]
unsafe impl Send for Osc1timer1 {}
#[cfg(feature = "osc1timer1")]
impl Osc1timer1 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffd0_1000;
}
#[doc = "Registers in the timer module. The timer IP core supports multiple timers but it is configured for just one timer. The term Timer1 refers to this one timer in the IP core and not the module instance."]
#[cfg(feature = "osc1timer1")]
pub mod osc1timer1;
#[doc = "Registers in the L4 Watchdog module"]
#[cfg(feature = "l4wd0")]
pub struct L4wd0 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "l4wd0")]
unsafe impl Send for L4wd0 {}
#[cfg(feature = "l4wd0")]
impl L4wd0 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffd0_2000;
}
#[doc = "Registers in the L4 Watchdog module"]
#[cfg(feature = "l4wd0")]
pub mod l4wd0;
#[doc = "Registers in the L4 Watchdog module"]
#[cfg(feature = "l4wd1")]
pub struct L4wd1 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "l4wd1")]
unsafe impl Send for L4wd1 {}
#[cfg(feature = "l4wd1")]
impl L4wd1 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffd0_3000;
}
#[doc = "Registers in the L4 Watchdog module"]
#[cfg(feature = "l4wd1")]
pub mod l4wd1;
#[doc = "Registers in the Clock Manager module"]
#[cfg(feature = "clkmgr")]
pub struct Clkmgr {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "clkmgr")]
unsafe impl Send for Clkmgr {}
#[cfg(feature = "clkmgr")]
impl Clkmgr {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffd0_4000;
}
#[doc = "Registers in the Clock Manager module"]
#[cfg(feature = "clkmgr")]
pub mod clkmgr;
#[doc = "Registers in the Reset Manager module"]
#[cfg(feature = "rstmgr")]
pub struct Rstmgr {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "rstmgr")]
unsafe impl Send for Rstmgr {}
#[cfg(feature = "rstmgr")]
impl Rstmgr {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffd0_5000;
}
#[doc = "Registers in the Reset Manager module"]
#[cfg(feature = "rstmgr")]
pub mod rstmgr;
#[doc = "Registers in the System Manager module"]
#[cfg(feature = "sysmgr")]
pub struct Sysmgr {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "sysmgr")]
unsafe impl Send for Sysmgr {}
#[cfg(feature = "sysmgr")]
impl Sysmgr {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffd0_8000;
}
#[doc = "Registers in the System Manager module"]
#[cfg(feature = "sysmgr")]
pub mod sysmgr;
#[doc = "Address space allocated to the nonsecure DMA. For detailed information about the use of this address space, [url=http://infocenter.arm.com/help/topic/com.arm.doc.ddi0424b/index.html]click here[/url]
to access the ARM documentation for the DMA-330."]
#[cfg(feature = "dmanonsecure")]
pub struct Dmanonsecure {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "dmanonsecure")]
unsafe impl Send for Dmanonsecure {}
#[cfg(feature = "dmanonsecure")]
impl Dmanonsecure {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffe0_0000;
}
#[doc = "Address space allocated to the nonsecure DMA. For detailed information about the use of this address space, \\[url=http://infocenter.arm.com/help/topic/com.arm.doc.ddi0424b/index.html\\]click here\\[/url\\]
to access the ARM documentation for the DMA-330."]
#[cfg(feature = "dmanonsecure")]
pub mod dmanonsecure;
#[doc = "Address space allocated to the secure DMA. For detailed information about the use of this address space, [url=http://infocenter.arm.com/help/topic/com.arm.doc.ddi0424b/index.html]click here[/url]
to access the ARM documentation for the DMA-330."]
#[cfg(feature = "dmasecure")]
pub struct Dmasecure {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "dmasecure")]
unsafe impl Send for Dmasecure {}
#[cfg(feature = "dmasecure")]
impl Dmasecure {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffe0_1000;
}
#[doc = "Address space allocated to the secure DMA. For detailed information about the use of this address space, \\[url=http://infocenter.arm.com/help/topic/com.arm.doc.ddi0424b/index.html\\]click here\\[/url\\]
to access the ARM documentation for the DMA-330."]
#[cfg(feature = "dmasecure")]
pub mod dmasecure;
#[doc = "Registers in the SPI Slave module"]
#[cfg(feature = "spis0")]
pub struct Spis0 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "spis0")]
unsafe impl Send for Spis0 {}
#[cfg(feature = "spis0")]
impl Spis0 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffe0_2000;
}
#[doc = "Registers in the SPI Slave module"]
#[cfg(feature = "spis0")]
pub mod spis0;
#[doc = "Registers in the SPI Slave module"]
#[cfg(feature = "spis1")]
pub struct Spis1 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "spis1")]
unsafe impl Send for Spis1 {}
#[cfg(feature = "spis1")]
impl Spis1 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xffe0_3000;
}
#[doc = "Registers in the SPI Slave module"]
#[cfg(feature = "spis1")]
pub mod spis1;
#[doc = "Registers in the SPI Master module"]
#[cfg(feature = "spim0")]
pub struct Spim0 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "spim0")]
unsafe impl Send for Spim0 {}
#[cfg(feature = "spim0")]
impl Spim0 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xfff0_0000;
}
#[doc = "Registers in the SPI Master module"]
#[cfg(feature = "spim0")]
pub mod spim0;
#[doc = "Registers in the SPI Master module"]
#[cfg(feature = "spim1")]
pub struct Spim1 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "spim1")]
unsafe impl Send for Spim1 {}
#[cfg(feature = "spim1")]
impl Spim1 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xfff0_1000;
}
#[doc = "Registers in the SPI Master module"]
#[cfg(feature = "spim1")]
pub mod spim1;
#[doc = "Registers in the Scan Manager module. These registers are implemented by an ARM JTAG-AP module from the ARM DAP. Some register and field names have been changed to match the usage in the Scan Manager. If modified, the corresponding names from the ARM documentation are provided. Only registers and fields that are relevant to the JTAG-AP use in the Scan Manager are listed."]
#[cfg(feature = "scanmgr")]
pub struct Scanmgr {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "scanmgr")]
unsafe impl Send for Scanmgr {}
#[cfg(feature = "scanmgr")]
impl Scanmgr {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xfff0_2000;
}
#[doc = "Registers in the Scan Manager module. These registers are implemented by an ARM JTAG-AP module from the ARM DAP. Some register and field names have been changed to match the usage in the Scan Manager. If modified, the corresponding names from the ARM documentation are provided. Only registers and fields that are relevant to the JTAG-AP use in the Scan Manager are listed."]
#[cfg(feature = "scanmgr")]
pub mod scanmgr;
#[doc = "Address space allocated to the MPU SCU. For detailed information about the use of this address space, [url=http://infocenter.arm.com/help/topic/com.arm.doc.ddi0407f/index.html]click here[/url]
to access the ARM documentation for the Cortex-A9 MPCore."]
#[cfg(feature = "mpuscu")]
pub struct Mpuscu {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "mpuscu")]
unsafe impl Send for Mpuscu {}
#[cfg(feature = "mpuscu")]
impl Mpuscu {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xfffe_c000;
}
#[doc = "Address space allocated to the MPU SCU. For detailed information about the use of this address space, \\[url=http://infocenter.arm.com/help/topic/com.arm.doc.ddi0407f/index.html\\]click here\\[/url\\]
to access the ARM documentation for the Cortex-A9 MPCore."]
#[cfg(feature = "mpuscu")]
pub mod mpuscu;
#[doc = "Address space allocated to the MPU L2 cache controller. For detailed information about the use of this address space, [url=http://infocenter.arm.com/help/topic/com.arm.doc.ddi0246e/index.html]click here[/url]
to access the ARM documentation for the L2C-301."]
#[cfg(feature = "mpul2")]
pub struct Mpul2 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "mpul2")]
unsafe impl Send for Mpul2 {}
#[cfg(feature = "mpul2")]
impl Mpul2 {
    #[doc = r"Pointer to the register block"]
    pub const BASE: u32 = 0xfffe_f000;
}
#[doc = "Address space allocated to the MPU L2 cache controller. For detailed information about the use of this address space, \\[url=http://infocenter.arm.com/help/topic/com.arm.doc.ddi0246e/index.html\\]click here\\[/url\\]
to access the ARM documentation for the L2C-301."]
#[cfg(feature = "mpul2")]
pub mod mpul2;
