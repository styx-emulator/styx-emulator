// SPDX-License-Identifier: BSD-2-Clause
#[doc = "Register `bypass` reader"]
pub type R = crate::R<BypassSpec>;
#[doc = "Register `bypass` writer"]
pub type W = crate::W<BypassSpec>;
#[doc = "Field `mainpll` reader - When set, causes the Main PLL VCO and counters to be bypassed so that all clocks generated by the Main PLL are directly driven from the Main PLL input clock. The bypass source for Main PLL is the external eosc1_clk. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
pub type MainpllR = crate::BitReader;
#[doc = "Field `mainpll` writer - When set, causes the Main PLL VCO and counters to be bypassed so that all clocks generated by the Main PLL are directly driven from the Main PLL input clock. The bypass source for Main PLL is the external eosc1_clk. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
pub type MainpllW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `sdrpll` reader - When set, causes the SDRAM PLL VCO and counters to be bypassed so that all clocks generated by the SDRAM PLL are directly driven from either eosc1_clk or the SDRAM PLL input clock. The bypass clock source for SDRAM PLL is determined by the SDRAM PLL Bypass Source Register bit. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
pub type SdrpllR = crate::BitReader;
#[doc = "Field `sdrpll` writer - When set, causes the SDRAM PLL VCO and counters to be bypassed so that all clocks generated by the SDRAM PLL are directly driven from either eosc1_clk or the SDRAM PLL input clock. The bypass clock source for SDRAM PLL is determined by the SDRAM PLL Bypass Source Register bit. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
pub type SdrpllW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "This bit defines the bypass source forSDRAM PLL. When changing fields that affect VCO lock the PLL must be bypassed and this bit must be set to OSC1_CLK. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Sdrpllsrc {
    #[doc = "0: `0`"]
    SelectEosc1 = 0,
    #[doc = "1: `1`"]
    SelectInputMux = 1,
}
impl From<Sdrpllsrc> for bool {
    #[inline(always)]
    fn from(variant: Sdrpllsrc) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `sdrpllsrc` reader - This bit defines the bypass source forSDRAM PLL. When changing fields that affect VCO lock the PLL must be bypassed and this bit must be set to OSC1_CLK. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
pub type SdrpllsrcR = crate::BitReader<Sdrpllsrc>;
impl SdrpllsrcR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Sdrpllsrc {
        match self.bits {
            false => Sdrpllsrc::SelectEosc1,
            true => Sdrpllsrc::SelectInputMux,
        }
    }
    #[doc = "`0`"]
    #[inline(always)]
    pub fn is_select_eosc1(&self) -> bool {
        *self == Sdrpllsrc::SelectEosc1
    }
    #[doc = "`1`"]
    #[inline(always)]
    pub fn is_select_input_mux(&self) -> bool {
        *self == Sdrpllsrc::SelectInputMux
    }
}
#[doc = "Field `sdrpllsrc` writer - This bit defines the bypass source forSDRAM PLL. When changing fields that affect VCO lock the PLL must be bypassed and this bit must be set to OSC1_CLK. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
pub type SdrpllsrcW<'a, REG> = crate::BitWriter<'a, REG, Sdrpllsrc>;
impl<'a, REG> SdrpllsrcW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "`0`"]
    #[inline(always)]
    pub fn select_eosc1(self) -> &'a mut crate::W<REG> {
        self.variant(Sdrpllsrc::SelectEosc1)
    }
    #[doc = "`1`"]
    #[inline(always)]
    pub fn select_input_mux(self) -> &'a mut crate::W<REG> {
        self.variant(Sdrpllsrc::SelectInputMux)
    }
}
#[doc = "Field `perpll` reader - When set, causes the Peripheral PLL VCO and counters to be bypassed so that all clocks generated by the Peripheral PLL are directly driven from either eosc1_clk or the Peripheral PLL input clock. The bypass clock source for Peripheral PLL is determined by the Peripheral PLL Bypass Source Register bit. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
pub type PerpllR = crate::BitReader;
#[doc = "Field `perpll` writer - When set, causes the Peripheral PLL VCO and counters to be bypassed so that all clocks generated by the Peripheral PLL are directly driven from either eosc1_clk or the Peripheral PLL input clock. The bypass clock source for Peripheral PLL is determined by the Peripheral PLL Bypass Source Register bit. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
pub type PerpllW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "This bit defines the bypass source forPeripheral PLL. When changing fields that affect VCO lock the PLL must be bypassed and this bit must be set to OSC1_CLK. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Perpllsrc {
    #[doc = "0: `0`"]
    SelectEosc1 = 0,
    #[doc = "1: `1`"]
    SelectInputMux = 1,
}
impl From<Perpllsrc> for bool {
    #[inline(always)]
    fn from(variant: Perpllsrc) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `perpllsrc` reader - This bit defines the bypass source forPeripheral PLL. When changing fields that affect VCO lock the PLL must be bypassed and this bit must be set to OSC1_CLK. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
pub type PerpllsrcR = crate::BitReader<Perpllsrc>;
impl PerpllsrcR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Perpllsrc {
        match self.bits {
            false => Perpllsrc::SelectEosc1,
            true => Perpllsrc::SelectInputMux,
        }
    }
    #[doc = "`0`"]
    #[inline(always)]
    pub fn is_select_eosc1(&self) -> bool {
        *self == Perpllsrc::SelectEosc1
    }
    #[doc = "`1`"]
    #[inline(always)]
    pub fn is_select_input_mux(&self) -> bool {
        *self == Perpllsrc::SelectInputMux
    }
}
#[doc = "Field `perpllsrc` writer - This bit defines the bypass source forPeripheral PLL. When changing fields that affect VCO lock the PLL must be bypassed and this bit must be set to OSC1_CLK. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
pub type PerpllsrcW<'a, REG> = crate::BitWriter<'a, REG, Perpllsrc>;
impl<'a, REG> PerpllsrcW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "`0`"]
    #[inline(always)]
    pub fn select_eosc1(self) -> &'a mut crate::W<REG> {
        self.variant(Perpllsrc::SelectEosc1)
    }
    #[doc = "`1`"]
    #[inline(always)]
    pub fn select_input_mux(self) -> &'a mut crate::W<REG> {
        self.variant(Perpllsrc::SelectInputMux)
    }
}
impl R {
    #[doc = "Bit 0 - When set, causes the Main PLL VCO and counters to be bypassed so that all clocks generated by the Main PLL are directly driven from the Main PLL input clock. The bypass source for Main PLL is the external eosc1_clk. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
    #[inline(always)]
    pub fn mainpll(&self) -> MainpllR {
        MainpllR::new((self.bits & 1) != 0)
    }
    #[doc = "Bit 1 - When set, causes the SDRAM PLL VCO and counters to be bypassed so that all clocks generated by the SDRAM PLL are directly driven from either eosc1_clk or the SDRAM PLL input clock. The bypass clock source for SDRAM PLL is determined by the SDRAM PLL Bypass Source Register bit. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
    #[inline(always)]
    pub fn sdrpll(&self) -> SdrpllR {
        SdrpllR::new(((self.bits >> 1) & 1) != 0)
    }
    #[doc = "Bit 2 - This bit defines the bypass source forSDRAM PLL. When changing fields that affect VCO lock the PLL must be bypassed and this bit must be set to OSC1_CLK. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
    #[inline(always)]
    pub fn sdrpllsrc(&self) -> SdrpllsrcR {
        SdrpllsrcR::new(((self.bits >> 2) & 1) != 0)
    }
    #[doc = "Bit 3 - When set, causes the Peripheral PLL VCO and counters to be bypassed so that all clocks generated by the Peripheral PLL are directly driven from either eosc1_clk or the Peripheral PLL input clock. The bypass clock source for Peripheral PLL is determined by the Peripheral PLL Bypass Source Register bit. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
    #[inline(always)]
    pub fn perpll(&self) -> PerpllR {
        PerpllR::new(((self.bits >> 3) & 1) != 0)
    }
    #[doc = "Bit 4 - This bit defines the bypass source forPeripheral PLL. When changing fields that affect VCO lock the PLL must be bypassed and this bit must be set to OSC1_CLK. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
    #[inline(always)]
    pub fn perpllsrc(&self) -> PerpllsrcR {
        PerpllsrcR::new(((self.bits >> 4) & 1) != 0)
    }
}
impl W {
    #[doc = "Bit 0 - When set, causes the Main PLL VCO and counters to be bypassed so that all clocks generated by the Main PLL are directly driven from the Main PLL input clock. The bypass source for Main PLL is the external eosc1_clk. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
    #[inline(always)]
    #[must_use]
    pub fn mainpll(&mut self) -> MainpllW<BypassSpec> {
        MainpllW::new(self, 0)
    }
    #[doc = "Bit 1 - When set, causes the SDRAM PLL VCO and counters to be bypassed so that all clocks generated by the SDRAM PLL are directly driven from either eosc1_clk or the SDRAM PLL input clock. The bypass clock source for SDRAM PLL is determined by the SDRAM PLL Bypass Source Register bit. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
    #[inline(always)]
    #[must_use]
    pub fn sdrpll(&mut self) -> SdrpllW<BypassSpec> {
        SdrpllW::new(self, 1)
    }
    #[doc = "Bit 2 - This bit defines the bypass source forSDRAM PLL. When changing fields that affect VCO lock the PLL must be bypassed and this bit must be set to OSC1_CLK. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
    #[inline(always)]
    #[must_use]
    pub fn sdrpllsrc(&mut self) -> SdrpllsrcW<BypassSpec> {
        SdrpllsrcW::new(self, 2)
    }
    #[doc = "Bit 3 - When set, causes the Peripheral PLL VCO and counters to be bypassed so that all clocks generated by the Peripheral PLL are directly driven from either eosc1_clk or the Peripheral PLL input clock. The bypass clock source for Peripheral PLL is determined by the Peripheral PLL Bypass Source Register bit. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
    #[inline(always)]
    #[must_use]
    pub fn perpll(&mut self) -> PerpllW<BypassSpec> {
        PerpllW::new(self, 3)
    }
    #[doc = "Bit 4 - This bit defines the bypass source forPeripheral PLL. When changing fields that affect VCO lock the PLL must be bypassed and this bit must be set to OSC1_CLK. The reset value for this bit is applied on a cold reset. Warm reset has no affect on this bit."]
    #[inline(always)]
    #[must_use]
    pub fn perpllsrc(&mut self) -> PerpllsrcW<BypassSpec> {
        PerpllsrcW::new(self, 4)
    }
}
#[doc = "Contains fields that control bypassing each PLL.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bypass::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bypass::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct BypassSpec;
impl crate::RegisterSpec for BypassSpec {
    type Ux = u32;
    const OFFSET: u64 = 4u64;
}
#[doc = "`read()` method returns [`bypass::R`](R) reader structure"]
impl crate::Readable for BypassSpec {}
#[doc = "`write(|w| ..)` method takes [`bypass::W`](W) writer structure"]
impl crate::Writable for BypassSpec {
    type Safety = crate::Unsafe;
    const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
    const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
}
#[doc = "`reset()` method sets bypass to value 0x0b"]
impl crate::Resettable for BypassSpec {
    const RESET_VALUE: u32 = 0x0b;
}
