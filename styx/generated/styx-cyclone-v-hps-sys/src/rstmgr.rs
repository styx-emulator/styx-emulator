// SPDX-License-Identifier: BSD-2-Clause
#[repr(C)]
#[doc = "Register block"]
pub struct RegisterBlock {
    stat: Stat,
    ctrl: Ctrl,
    counts: Counts,
    _reserved3: [u8; 0x04],
    mpumodrst: Mpumodrst,
    permodrst: Permodrst,
    per2modrst: Per2modrst,
    brgmodrst: Brgmodrst,
    miscmodrst: Miscmodrst,
}
impl crate::FromBytes for RegisterBlock {}
impl RegisterBlock {
    #[doc = "0x00 - The STAT register contains bits that indicate the reset source or a timeout event. For reset sources, a field is 1 if its associated reset requester caused the reset. For timeout events, a field is 1 if its associated timeout occured as part of a hardware sequenced warm/debug reset. Software clears bits by writing them with a value of 1. Writes to bits with a value of 0 are ignored. After a cold reset is complete, all bits are reset to their reset value except for the bit(s) that indicate the source of the cold reset. If multiple cold reset requests overlap with each other, the source de-asserts the request last will be logged. The other reset request source(s) de-assert the request in the same cycle will also be logged, the rest of the fields are reset to default value of 0. After a warm reset is complete, the bit(s) that indicate the source of the warm reset are set to 1. A warm reset doesn't clear any of the bits in the STAT register; these bits must be cleared by software writing the STAT register."]
    #[inline(always)]
    pub const fn stat(&self) -> &Stat {
        &self.stat
    }
    #[doc = "0x04 - The CTRL register is used by software to control reset behavior.It includes fields for software to initiate the cold and warm reset, enable hardware handshake with other modules before warm reset, and perform software handshake. The software handshake sequence must match the hardware sequence. Software mustde-assert the handshake request after asserting warm reset and before de-assert the warm reset. Fields are only reset by a cold reset."]
    #[inline(always)]
    pub const fn ctrl(&self) -> &Ctrl {
        &self.ctrl
    }
    #[doc = "0x08 - The COUNTS register is used by software to control reset behavior.It includes fields for software to control the behavior of the warm reset and nRST pin. Fields are only reset by a cold reset."]
    #[inline(always)]
    pub const fn counts(&self) -> &Counts {
        &self.counts
    }
    #[doc = "0x10 - The MPUMODRST register is used by software to trigger module resets (individual module reset signals). Software explicitly asserts and de-asserts module reset signals by writing bits in the appropriate *MODRST register. It is up to software to ensure module reset signals are asserted for the appropriate length of time and are de-asserted in the correct order. It is also up to software to not assert a module reset signal that would prevent software from de-asserting the module reset signal. For example, software should not assert the module reset to the CPU executing the software. Software writes a bit to 1 to assert the module reset signal and to 0 to de-assert the module reset signal. All fields except CPU1 are only reset by a cold reset. The CPU1 field is reset by a cold reset. The CPU1 field is also reset by a warm reset if not masked by the corresponding MPUWARMMASK field."]
    #[inline(always)]
    pub const fn mpumodrst(&self) -> &Mpumodrst {
        &self.mpumodrst
    }
    #[doc = "0x14 - The PERMODRST register is used by software to trigger module resets (individual module reset signals). Software explicitly asserts and de-asserts module reset signals by writing bits in the appropriate *MODRST register. It is up to software to ensure module reset signals are asserted for the appropriate length of time and are de-asserted in the correct order. It is also up to software to not assert a module reset signal that would prevent software from de-asserting the module reset signal. For example, software should not assert the module reset to the CPU executing the software. Software writes a bit to 1 to assert the module reset signal and to 0 to de-assert the module reset signal. All fields are reset by a cold reset.All fields are also reset by a warm reset if not masked by the corresponding PERWARMMASK field. The reset value of all fields is 1. This holds the corresponding module in reset until software is ready to release the module from reset by writing 0 to its field."]
    #[inline(always)]
    pub const fn permodrst(&self) -> &Permodrst {
        &self.permodrst
    }
    #[doc = "0x18 - The PER2MODRST register is used by software to trigger module resets (individual module reset signals). Software explicitly asserts and de-asserts module reset signals by writing bits in the appropriate *MODRST register. It is up to software to ensure module reset signals are asserted for the appropriate length of time and are de-asserted in the correct order. It is also up to software to not assert a module reset signal that would prevent software from de-asserting the module reset signal. For example, software should not assert the module reset to the CPU executing the software. Software writes a bit to 1 to assert the module reset signal and to 0 to de-assert the module reset signal. All fields are reset by a cold reset.All fields are also reset by a warm reset if not masked by the corresponding PERWARMMASK field. The reset value of all fields is 1. This holds the corresponding module in reset until software is ready to release the module from reset by writing 0 to its field."]
    #[inline(always)]
    pub const fn per2modrst(&self) -> &Per2modrst {
        &self.per2modrst
    }
    #[doc = "0x1c - The BRGMODRST register is used by software to trigger module resets (individual module reset signals). Software explicitly asserts and de-asserts module reset signals by writing bits in the appropriate *MODRST register. It is up to software to ensure module reset signals are asserted for the appropriate length of time and are de-asserted in the correct order. It is also up to software to not assert a module reset signal that would prevent software from de-asserting the module reset signal. For example, software should not assert the module reset to the CPU executing the software. Software writes a bit to 1 to assert the module reset signal and to 0 to de-assert the module reset signal. All fields are reset by a cold reset.All fields are also reset by a warm reset if not masked by the corresponding BRGWARMMASK field. The reset value of all fields is 1. This holds the corresponding module in reset until software is ready to release the module from reset by writing 0 to its field."]
    #[inline(always)]
    pub const fn brgmodrst(&self) -> &Brgmodrst {
        &self.brgmodrst
    }
    #[doc = "0x20 - The MISCMODRST register is used by software to trigger module resets (individual module reset signals). Software explicitly asserts and de-asserts module reset signals by writing bits in the appropriate *MODRST register. It is up to software to ensure module reset signals are asserted for the appropriate length of time and are de-asserted in the correct order. It is also up to software to not assert a module reset signal that would prevent software from de-asserting the module reset signal. For example, software should not assert the module reset to the CPU executing the software. Software writes a bit to 1 to assert the module reset signal and to 0 to de-assert the module reset signal. All fields are only reset by a cold reset"]
    #[inline(always)]
    pub const fn miscmodrst(&self) -> &Miscmodrst {
        &self.miscmodrst
    }
}
#[doc = "stat (rw) register accessor: The STAT register contains bits that indicate the reset source or a timeout event. For reset sources, a field is 1 if its associated reset requester caused the reset. For timeout events, a field is 1 if its associated timeout occured as part of a hardware sequenced warm/debug reset. Software clears bits by writing them with a value of 1. Writes to bits with a value of 0 are ignored. After a cold reset is complete, all bits are reset to their reset value except for the bit(s) that indicate the source of the cold reset. If multiple cold reset requests overlap with each other, the source de-asserts the request last will be logged. The other reset request source(s) de-assert the request in the same cycle will also be logged, the rest of the fields are reset to default value of 0. After a warm reset is complete, the bit(s) that indicate the source of the warm reset are set to 1. A warm reset doesn't clear any of the bits in the STAT register; these bits must be cleared by software writing the STAT register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`stat::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stat::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@stat`]
module"]
#[doc(alias = "stat")]
pub type Stat = crate::Reg<stat::StatSpec>;
#[doc = "The STAT register contains bits that indicate the reset source or a timeout event. For reset sources, a field is 1 if its associated reset requester caused the reset. For timeout events, a field is 1 if its associated timeout occured as part of a hardware sequenced warm/debug reset. Software clears bits by writing them with a value of 1. Writes to bits with a value of 0 are ignored. After a cold reset is complete, all bits are reset to their reset value except for the bit(s) that indicate the source of the cold reset. If multiple cold reset requests overlap with each other, the source de-asserts the request last will be logged. The other reset request source(s) de-assert the request in the same cycle will also be logged, the rest of the fields are reset to default value of 0. After a warm reset is complete, the bit(s) that indicate the source of the warm reset are set to 1. A warm reset doesn't clear any of the bits in the STAT register; these bits must be cleared by software writing the STAT register."]
pub mod stat;
#[doc = "ctrl (rw) register accessor: The CTRL register is used by software to control reset behavior.It includes fields for software to initiate the cold and warm reset, enable hardware handshake with other modules before warm reset, and perform software handshake. The software handshake sequence must match the hardware sequence. Software mustde-assert the handshake request after asserting warm reset and before de-assert the warm reset. Fields are only reset by a cold reset.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`]
module"]
#[doc(alias = "ctrl")]
pub type Ctrl = crate::Reg<ctrl::CtrlSpec>;
#[doc = "The CTRL register is used by software to control reset behavior.It includes fields for software to initiate the cold and warm reset, enable hardware handshake with other modules before warm reset, and perform software handshake. The software handshake sequence must match the hardware sequence. Software mustde-assert the handshake request after asserting warm reset and before de-assert the warm reset. Fields are only reset by a cold reset."]
pub mod ctrl;
#[doc = "counts (rw) register accessor: The COUNTS register is used by software to control reset behavior.It includes fields for software to control the behavior of the warm reset and nRST pin. Fields are only reset by a cold reset.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`counts::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`counts::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@counts`]
module"]
#[doc(alias = "counts")]
pub type Counts = crate::Reg<counts::CountsSpec>;
#[doc = "The COUNTS register is used by software to control reset behavior.It includes fields for software to control the behavior of the warm reset and nRST pin. Fields are only reset by a cold reset."]
pub mod counts;
#[doc = "mpumodrst (rw) register accessor: The MPUMODRST register is used by software to trigger module resets (individual module reset signals). Software explicitly asserts and de-asserts module reset signals by writing bits in the appropriate *MODRST register. It is up to software to ensure module reset signals are asserted for the appropriate length of time and are de-asserted in the correct order. It is also up to software to not assert a module reset signal that would prevent software from de-asserting the module reset signal. For example, software should not assert the module reset to the CPU executing the software. Software writes a bit to 1 to assert the module reset signal and to 0 to de-assert the module reset signal. All fields except CPU1 are only reset by a cold reset. The CPU1 field is reset by a cold reset. The CPU1 field is also reset by a warm reset if not masked by the corresponding MPUWARMMASK field.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`mpumodrst::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mpumodrst::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mpumodrst`]
module"]
#[doc(alias = "mpumodrst")]
pub type Mpumodrst = crate::Reg<mpumodrst::MpumodrstSpec>;
#[doc = "The MPUMODRST register is used by software to trigger module resets (individual module reset signals). Software explicitly asserts and de-asserts module reset signals by writing bits in the appropriate *MODRST register. It is up to software to ensure module reset signals are asserted for the appropriate length of time and are de-asserted in the correct order. It is also up to software to not assert a module reset signal that would prevent software from de-asserting the module reset signal. For example, software should not assert the module reset to the CPU executing the software. Software writes a bit to 1 to assert the module reset signal and to 0 to de-assert the module reset signal. All fields except CPU1 are only reset by a cold reset. The CPU1 field is reset by a cold reset. The CPU1 field is also reset by a warm reset if not masked by the corresponding MPUWARMMASK field."]
pub mod mpumodrst;
#[doc = "permodrst (rw) register accessor: The PERMODRST register is used by software to trigger module resets (individual module reset signals). Software explicitly asserts and de-asserts module reset signals by writing bits in the appropriate *MODRST register. It is up to software to ensure module reset signals are asserted for the appropriate length of time and are de-asserted in the correct order. It is also up to software to not assert a module reset signal that would prevent software from de-asserting the module reset signal. For example, software should not assert the module reset to the CPU executing the software. Software writes a bit to 1 to assert the module reset signal and to 0 to de-assert the module reset signal. All fields are reset by a cold reset.All fields are also reset by a warm reset if not masked by the corresponding PERWARMMASK field. The reset value of all fields is 1. This holds the corresponding module in reset until software is ready to release the module from reset by writing 0 to its field.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`permodrst::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`permodrst::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@permodrst`]
module"]
#[doc(alias = "permodrst")]
pub type Permodrst = crate::Reg<permodrst::PermodrstSpec>;
#[doc = "The PERMODRST register is used by software to trigger module resets (individual module reset signals). Software explicitly asserts and de-asserts module reset signals by writing bits in the appropriate *MODRST register. It is up to software to ensure module reset signals are asserted for the appropriate length of time and are de-asserted in the correct order. It is also up to software to not assert a module reset signal that would prevent software from de-asserting the module reset signal. For example, software should not assert the module reset to the CPU executing the software. Software writes a bit to 1 to assert the module reset signal and to 0 to de-assert the module reset signal. All fields are reset by a cold reset.All fields are also reset by a warm reset if not masked by the corresponding PERWARMMASK field. The reset value of all fields is 1. This holds the corresponding module in reset until software is ready to release the module from reset by writing 0 to its field."]
pub mod permodrst;
#[doc = "per2modrst (rw) register accessor: The PER2MODRST register is used by software to trigger module resets (individual module reset signals). Software explicitly asserts and de-asserts module reset signals by writing bits in the appropriate *MODRST register. It is up to software to ensure module reset signals are asserted for the appropriate length of time and are de-asserted in the correct order. It is also up to software to not assert a module reset signal that would prevent software from de-asserting the module reset signal. For example, software should not assert the module reset to the CPU executing the software. Software writes a bit to 1 to assert the module reset signal and to 0 to de-assert the module reset signal. All fields are reset by a cold reset.All fields are also reset by a warm reset if not masked by the corresponding PERWARMMASK field. The reset value of all fields is 1. This holds the corresponding module in reset until software is ready to release the module from reset by writing 0 to its field.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`per2modrst::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`per2modrst::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@per2modrst`]
module"]
#[doc(alias = "per2modrst")]
pub type Per2modrst = crate::Reg<per2modrst::Per2modrstSpec>;
#[doc = "The PER2MODRST register is used by software to trigger module resets (individual module reset signals). Software explicitly asserts and de-asserts module reset signals by writing bits in the appropriate *MODRST register. It is up to software to ensure module reset signals are asserted for the appropriate length of time and are de-asserted in the correct order. It is also up to software to not assert a module reset signal that would prevent software from de-asserting the module reset signal. For example, software should not assert the module reset to the CPU executing the software. Software writes a bit to 1 to assert the module reset signal and to 0 to de-assert the module reset signal. All fields are reset by a cold reset.All fields are also reset by a warm reset if not masked by the corresponding PERWARMMASK field. The reset value of all fields is 1. This holds the corresponding module in reset until software is ready to release the module from reset by writing 0 to its field."]
pub mod per2modrst;
#[doc = "brgmodrst (rw) register accessor: The BRGMODRST register is used by software to trigger module resets (individual module reset signals). Software explicitly asserts and de-asserts module reset signals by writing bits in the appropriate *MODRST register. It is up to software to ensure module reset signals are asserted for the appropriate length of time and are de-asserted in the correct order. It is also up to software to not assert a module reset signal that would prevent software from de-asserting the module reset signal. For example, software should not assert the module reset to the CPU executing the software. Software writes a bit to 1 to assert the module reset signal and to 0 to de-assert the module reset signal. All fields are reset by a cold reset.All fields are also reset by a warm reset if not masked by the corresponding BRGWARMMASK field. The reset value of all fields is 1. This holds the corresponding module in reset until software is ready to release the module from reset by writing 0 to its field.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`brgmodrst::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`brgmodrst::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@brgmodrst`]
module"]
#[doc(alias = "brgmodrst")]
pub type Brgmodrst = crate::Reg<brgmodrst::BrgmodrstSpec>;
#[doc = "The BRGMODRST register is used by software to trigger module resets (individual module reset signals). Software explicitly asserts and de-asserts module reset signals by writing bits in the appropriate *MODRST register. It is up to software to ensure module reset signals are asserted for the appropriate length of time and are de-asserted in the correct order. It is also up to software to not assert a module reset signal that would prevent software from de-asserting the module reset signal. For example, software should not assert the module reset to the CPU executing the software. Software writes a bit to 1 to assert the module reset signal and to 0 to de-assert the module reset signal. All fields are reset by a cold reset.All fields are also reset by a warm reset if not masked by the corresponding BRGWARMMASK field. The reset value of all fields is 1. This holds the corresponding module in reset until software is ready to release the module from reset by writing 0 to its field."]
pub mod brgmodrst;
#[doc = "miscmodrst (rw) register accessor: The MISCMODRST register is used by software to trigger module resets (individual module reset signals). Software explicitly asserts and de-asserts module reset signals by writing bits in the appropriate *MODRST register. It is up to software to ensure module reset signals are asserted for the appropriate length of time and are de-asserted in the correct order. It is also up to software to not assert a module reset signal that would prevent software from de-asserting the module reset signal. For example, software should not assert the module reset to the CPU executing the software. Software writes a bit to 1 to assert the module reset signal and to 0 to de-assert the module reset signal. All fields are only reset by a cold reset\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`miscmodrst::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`miscmodrst::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@miscmodrst`]
module"]
#[doc(alias = "miscmodrst")]
pub type Miscmodrst = crate::Reg<miscmodrst::MiscmodrstSpec>;
#[doc = "The MISCMODRST register is used by software to trigger module resets (individual module reset signals). Software explicitly asserts and de-asserts module reset signals by writing bits in the appropriate *MODRST register. It is up to software to ensure module reset signals are asserted for the appropriate length of time and are de-asserted in the correct order. It is also up to software to not assert a module reset signal that would prevent software from de-asserting the module reset signal. For example, software should not assert the module reset to the CPU executing the software. Software writes a bit to 1 to assert the module reset signal and to 0 to de-assert the module reset signal. All fields are only reset by a cold reset"]
pub mod miscmodrst;
